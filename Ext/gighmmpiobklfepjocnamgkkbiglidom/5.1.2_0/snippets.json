{"injectedCode":"/**\n * This file is part of eyeo's Anti-Circumvention Snippets module (@eyeo/snippets),\n * Copyright (C) 2006-present eyeo GmbH\n *\n * @eyeo/snippets is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 3 as\n * published by the Free Software Foundation.\n *\n * @eyeo/snippets is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with @eyeo/snippets.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n\"use strict\";\n\nconst $$1 = Proxy;\n\nconst {apply: a, bind: b, call: c} = Function;\n\nconst apply$2 = c.bind(a);\n\nconst bind = c.bind(b);\n\nconst call = c.bind(c);\n\nconst callerHandler = {\n    get(target, name) {\n        return bind(c, target[name]);\n    }\n};\n\nconst caller = target => new $$1(target, callerHandler);\n\nconst proxy = (source, target) => new $$1(source, {\n    apply: (_, self, args) => apply$2(target, self, args)\n});\n\nconst handler$2 = {\n    get(target, name) {\n        return bind(target[name], target);\n    }\n};\n\nconst bound = target => new $$1(target, handler$2);\n\nconst {assign: assign$1, defineProperties: defineProperties$1, freeze: freeze$1, getOwnPropertyDescriptor: getOwnPropertyDescriptor$3, getOwnPropertyDescriptors: getOwnPropertyDescriptors$1, getPrototypeOf: getPrototypeOf} = bound(Object);\n\nconst {hasOwnProperty: hasOwnProperty} = caller({});\n\nconst {species: species} = Symbol;\n\nconst handler$1 = {\n    get(target, name) {\n        const Native = target[name];\n        class Secure extends Native {}\n        const proto = getOwnPropertyDescriptors$1(Native.prototype);\n        delete proto.constructor;\n        freeze$1(defineProperties$1(Secure.prototype, proto));\n        const statics = getOwnPropertyDescriptors$1(Native);\n        delete statics.length;\n        delete statics.prototype;\n        statics[species] = {\n            value: Secure\n        };\n        return freeze$1(defineProperties$1(Secure, statics));\n    }\n};\n\nconst secure = target => new $$1(target, handler$1)\n/**\n * @typedef {object} Environment\n * @property {Array.<Array>} debugCSSProperties Highlighting options.\n * CSS properties to be applied to the targeted element.\n * @property {string} world Target injection world. 'ISOLATED' or 'MAIN'.\n */\n/**\n * A configuration object passed by integrators.\n * @type {Environment}\n * @private\n */;\n\nconst libEnvironment = typeof environment !== \"undefined\" ? environment : {};\n\nif (typeof globalThis === \"undefined\") window.globalThis = window;\n\nconst {apply: apply$1, ownKeys: ownKeys} = bound(Reflect);\n\nconst worldEnvDefined = \"world\" in libEnvironment;\n\nconst isIsolatedWorld = worldEnvDefined && libEnvironment.world === \"ISOLATED\";\n\nconst isMainWorld = worldEnvDefined && libEnvironment.world === \"MAIN\";\n\nconst isChrome = typeof chrome === \"object\" && !!chrome.runtime;\n\nconst isOtherThanChrome = typeof browser === \"object\" && !!browser.runtime;\n\nconst isExtensionContext$2 = !isMainWorld && (isIsolatedWorld || isChrome || isOtherThanChrome);\n\nconst copyIfExtension = value => isExtensionContext$2 ? value : create(value, getOwnPropertyDescriptors(value));\n\nconst {create: create, defineProperties: defineProperties, defineProperty: defineProperty, freeze: freeze, getOwnPropertyDescriptor: getOwnPropertyDescriptor$2, getOwnPropertyDescriptors: getOwnPropertyDescriptors} = bound(Object);\n\nconst invokes = bound(globalThis);\n\nconst classes = isExtensionContext$2 ? globalThis : secure(globalThis);\n\nconst {Map: Map$8, RegExp: RegExp$1, Set: Set$2, WeakMap: WeakMap$4, WeakSet: WeakSet$3} = classes;\n\nconst augment = (source, target, method = null) => {\n    const known = ownKeys(target);\n    for (const key of ownKeys(source)) {\n        if (known.includes(key)) continue;\n        const descriptor = getOwnPropertyDescriptor$2(source, key);\n        if (method && \"value\" in descriptor) {\n            const {value: value} = descriptor;\n            if (typeof value === \"function\") descriptor.value = method(value);\n        }\n        defineProperty(target, key, descriptor);\n    }\n};\n\nconst primitive = name => {\n    const Super = classes[name];\n    class Class extends Super {}\n    const {toString: toString, valueOf: valueOf} = Super.prototype;\n    defineProperties(Class.prototype, {\n        toString: {\n            value: toString\n        },\n        valueOf: {\n            value: valueOf\n        }\n    });\n    const type = name.toLowerCase();\n    const method = callback => function() {\n        const result = apply$1(callback, this, arguments);\n        return typeof result === type ? new Class(result) : result;\n    };\n    augment(Super, Class, method);\n    augment(Super.prototype, Class.prototype, method);\n    return Class;\n};\n\nconst variables$3 = freeze({\n    frozen: new WeakMap$4,\n    hidden: new WeakSet$3,\n    iframePropertiesToAbort: {\n        read: new Set$2,\n        write: new Set$2\n    },\n    abortedIframes: new WeakMap$4\n});\n\nconst startsCapitalized = new RegExp$1(\"^[A-Z]\");\n\nvar env = new Proxy(new Map$8([ [ \"chrome\", isExtensionContext$2 && (isChrome && chrome || isOtherThanChrome && browser) || void 0 ], [ \"isExtensionContext\", isExtensionContext$2 ], [ \"variables\", variables$3 ], [ \"console\", copyIfExtension(console) ], [ \"document\", globalThis.document ], [ \"performance\", copyIfExtension(performance) ], [ \"JSON\", copyIfExtension(JSON) ], [ \"Map\", Map$8 ], [ \"Math\", copyIfExtension(Math) ], [ \"Number\", isExtensionContext$2 ? Number : primitive(\"Number\") ], [ \"RegExp\", RegExp$1 ], [ \"Set\", Set$2 ], [ \"String\", isExtensionContext$2 ? String : primitive(\"String\") ], [ \"WeakMap\", WeakMap$4 ], [ \"WeakSet\", WeakSet$3 ], [ \"MouseEvent\", MouseEvent ] ]), {\n    get(map, key) {\n        if (map.has(key)) return map.get(key);\n        let value = globalThis[key];\n        if (typeof value === \"function\") value = (startsCapitalized.test(key) ? classes : invokes)[key];\n        map.set(key, value);\n        return value;\n    },\n    has(map, key) {\n        return map.has(key);\n    }\n});\n\n/*! (c) Andrea Giammarchi - ISC */ class WeakValue {\n    has() {\n        return false;\n    }\n    set() {}\n}\n\nconst helpers = {\n    WeakSet: WeakSet,\n    WeakMap: WeakMap,\n    WeakValue: WeakValue\n};\n\nconst {apply: apply} = Reflect;\n\nfunction transformOnce(callback) {\n    const {WeakSet: WeakSet, WeakMap: WeakMap, WeakValue: WeakValue} = this || helpers;\n    const ws = new WeakSet;\n    const wm = new WeakMap;\n    const wv = new WeakValue;\n    return function(any) {\n        if (ws.has(any)) return any;\n        if (wm.has(any)) return wm.get(any);\n        if (wv.has(any)) return wv.get(any);\n        const value = apply(callback, this, arguments);\n        ws.add(value);\n        if (value !== any) (typeof any === \"object\" && any ? wm : wv).set(any, value);\n        return value;\n    };\n}\n\nconst {Map: Map$7, WeakMap: WeakMap$3, WeakSet: WeakSet$2, setTimeout: setTimeout} = env;\n\nlet cleanup = true;\n\nlet cleanUpCallback = map => {\n    map.clear();\n    cleanup = !cleanup;\n};\n\nvar transformer = transformOnce.bind({\n    WeakMap: WeakMap$3,\n    WeakSet: WeakSet$2,\n    WeakValue: class extends Map$7 {\n        set(key, value) {\n            if (cleanup) {\n                cleanup = !cleanup;\n                setTimeout(cleanUpCallback, 0, this);\n            }\n            return super.set(key, value);\n        }\n    }\n});\n\nconst {concat: concat, includes: includes, join: join, reduce: reduce, unshift: unshift} = caller([]);\n\nconst {Map: Map$6, WeakMap: WeakMap$2} = secure(globalThis);\n\nconst map = new Map$6;\n\nconst descriptors = target => {\n    const chain = [];\n    let current = target;\n    while (current) {\n        if (map.has(current)) unshift(chain, map.get(current)); else {\n            const descriptors = getOwnPropertyDescriptors$1(current);\n            map.set(current, descriptors);\n            unshift(chain, descriptors);\n        }\n        current = getPrototypeOf(current);\n    }\n    unshift(chain, {});\n    return apply$2(assign$1, null, chain);\n};\n\nconst chain = source => {\n    const target = typeof source === \"function\" ? source.prototype : source;\n    const chained = descriptors(target);\n    const handler = {\n        get(target, key) {\n            if (key in chained) {\n                const {value: value, get: get} = chained[key];\n                if (get) return call(get, target);\n                if (typeof value === \"function\") return bind(value, target);\n            }\n            return target[key];\n        },\n        set(target, key, value) {\n            if (key in chained) {\n                const {set: set} = chained[key];\n                if (set) {\n                    call(set, target, value);\n                    return true;\n                }\n            }\n            target[key] = value;\n            return true;\n        }\n    };\n    return target => new Proxy(target, handler);\n};\n\nconst {isExtensionContext: isExtensionContext$1, Array: Array$2, Number: Number$1, String: String$1, Object: Object$9} = env;\n\nconst {isArray: isArray} = Array$2;\n\nconst {getOwnPropertyDescriptor: getOwnPropertyDescriptor$1, setPrototypeOf: setPrototypeOf$1} = Object$9;\n\nconst {toString: toString$1} = Object$9.prototype;\n\nconst {slice: slice} = String$1.prototype;\n\nconst getBrand = value => call(slice, call(toString$1, value), 8, -1);\n\nconst {get: nodeType} = getOwnPropertyDescriptor$1(Node.prototype, \"nodeType\");\n\nconst chained = isExtensionContext$1 ? {} : {\n    Attr: chain(Attr),\n    CanvasRenderingContext2D: chain(CanvasRenderingContext2D),\n    CSSStyleDeclaration: chain(CSSStyleDeclaration),\n    Document: chain(Document),\n    Element: chain(Element),\n    HTMLCanvasElement: chain(HTMLCanvasElement),\n    HTMLElement: chain(HTMLElement),\n    HTMLImageElement: chain(HTMLImageElement),\n    HTMLScriptElement: chain(HTMLScriptElement),\n    MutationRecord: chain(MutationRecord),\n    Node: chain(Node),\n    ShadowRoot: chain(ShadowRoot),\n    get CSS2Properties() {\n        return chained.CSSStyleDeclaration;\n    }\n};\n\nconst upgrade = (value, hint) => {\n    if (hint !== \"Element\" && hint in chained) return chained[hint](value);\n    if (isArray(value)) return setPrototypeOf$1(value, Array$2.prototype);\n    const brand = getBrand(value);\n    if (brand in chained) return chained[brand](value);\n    if (brand in env) return setPrototypeOf$1(value, env[brand].prototype);\n    if (\"nodeType\" in value) {\n        switch (call(nodeType, value)) {\n          case 1:\n            if (!(hint in chained)) throw new Error(\"unknown hint \" + hint);\n            return chained[hint](value);\n\n          case 2:\n            return chained.Attr(value);\n\n          case 3:\n            return chained.Node(value);\n\n          case 9:\n            return chained.Document(value);\n        }\n    }\n    throw new Error(\"unknown brand \" + brand);\n};\n\n/** @type {<T>(t:T)=>t} Any value that can be upgraded or wrapped */ var $ = isExtensionContext$1 ? value => value === window ? env : value : transformer(((value, hint = \"Element\") => {\n    if (value === window) return env;\n    switch (typeof value) {\n      case \"object\":\n        return value && upgrade(value, hint);\n\n      case \"string\":\n        return new String$1(value);\n\n      case \"number\":\n        return new Number$1(value);\n\n      default:\n        throw new Error(\"unsupported value\");\n    }\n}));\n\nconst handler = {\n    get(target, name) {\n        const context = target;\n        while (!hasOwnProperty(target, name)) target = getPrototypeOf(target);\n        const {get: get, set: set} = getOwnPropertyDescriptor$3(target, name);\n        return function() {\n            return arguments.length ? apply$2(set, context, arguments) : call(get, context);\n        };\n    }\n};\n\nconst accessor = target => new $$1(target, handler)\n/**\n * Whether debug mode is enabled.\n * @type {boolean}\n * @private\n */;\n\nlet debugging = false;\n\n/**\n * Tells if the debug mode is inactive.\n * @memberOf module:content/snippets.debug\n * @returns {boolean}\n */ function debug() {\n    return debugging;\n}\n\n/**\n * Enables debug mode.\n * @alias module:content/snippets.debug\n *\n * @example\n * example.com#$#debug; log 'Hello, world!'\n *\n * @since Adblock Plus 3.8\n */ function setDebug() {\n    debugging = true;\n}\n\nconst {console: console$3} = $(window);\n\nconst noop = () => {};\n\n/**\n * Logs its arguments to the console.\n *\n * This may be used for testing and debugging.\n *\n * @alias module:content/snippets.log\n *\n * @param {...*} [args] The arguments to log.\n *\n * @since Adblock Plus 3.3\n */ function log(...args) {\n    if (debug()) $(args).unshift(\"%c DEBUG\", \"font-weight: bold\");\n    console$3.log(...args);\n}\n\n/**\n * Returns a no-op if debugging mode is off, returns a bound log otherwise.\n * @param {string} name the debugger name (first logged value)\n * @returns {function} either a no-op function or the logger one\n */ function getDebugger(name) {\n    return bind(debug() ? log : noop, null, name);\n}\n\nlet {Math: Math$1, RegExp: RegExp} = $(window);\n\n/**\n * Escapes regular expression special characters in a string.\n *\n * The returned string may be passed to the `RegExp` constructor to match the\n * original string.\n *\n * @param {string} string The string in which to escape special characters.\n *\n * @returns {string} A new string with the special characters escaped.\n * @private\n */ function regexEscape(string) {\n    return $(string).replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n}\n\n/**\n * Converts a given pattern to a regular expression.\n *\n * @param {string} pattern The pattern to convert. If the pattern begins and\n *   ends with a slash (`/`), the text in between is treated as a regular\n *   expression. If the pattern begins with a slash (`/`) and it ends with a\n *   (`/i`), the text in between is treated as case insensitive regular\n *   expression; otherwise the pattern is treated as raw text.\n *\n * @returns {RegExp} A `RegExp` object based on the given pattern.\n * @private\n */ function toRegExp(pattern) {\n    let {length: length} = pattern;\n    if (length > 1 && pattern[0] === \"/\") {\n        let isCaseSensitive = pattern[length - 1] === \"/\";\n        if (isCaseSensitive || length > 2 && $(pattern).endsWith(\"/i\")) {\n            let args = [ $(pattern).slice(1, isCaseSensitive ? -1 : -2) ];\n            if (!isCaseSensitive) args.push(\"i\");\n            return new RegExp(...args);\n        }\n    }\n    return new RegExp(regexEscape(pattern));\n}\n\n/**\n * Generates a random alphanumeric ID consisting of 6 base-36 digits\n * from the range 100000..zzzzzz (both inclusive).\n *\n * @returns {string} The random ID.\n * @private\n */ function randomId() {\n    return $(Math$1.floor(Math$1.random() * 2116316160 + 60466176)).toString(36);\n}\n\nlet {parseFloat: parseFloat, variables: variables$2, Array: Array$1, Error: Error$7, Map: Map$5, Object: Object$8, ReferenceError: ReferenceError$2, Set: Set$1, WeakMap: WeakMap$1} = $(window);\n\nlet {onerror: onerror} = accessor(window);\n\nlet NodeProto$1 = Node.prototype;\n\nlet ElementProto$2 = Element.prototype;\n\nlet propertyAccessors = null;\n\nfunction wrapPropertyAccess(object, property, descriptor) {\n    let $property = $(property);\n    let dotIndex = $property.indexOf(\".\");\n    if (dotIndex == -1) {\n        let currentDescriptor = Object$8.getOwnPropertyDescriptor(object, property);\n        if (currentDescriptor && !currentDescriptor.configurable) return;\n        let newDescriptor = Object$8.assign({}, descriptor, {\n            configurable: true\n        });\n        if (!currentDescriptor && !newDescriptor.get && newDescriptor.set) {\n            let propertyValue = object[property];\n            newDescriptor.get = () => propertyValue;\n        }\n        Object$8.defineProperty(object, property, newDescriptor);\n        return;\n    }\n    let name = $property.slice(0, dotIndex);\n    property = $property.slice(dotIndex + 1);\n    let value = object[name];\n    if (value && (typeof value == \"object\" || typeof value == \"function\")) wrapPropertyAccess(value, property, descriptor);\n    let currentDescriptor = Object$8.getOwnPropertyDescriptor(object, name);\n    if (currentDescriptor && !currentDescriptor.configurable) return;\n    if (!propertyAccessors) propertyAccessors = new WeakMap$1;\n    if (!propertyAccessors.has(object)) propertyAccessors.set(object, new Map$5);\n    let properties = propertyAccessors.get(object);\n    if (properties.has(name)) {\n        properties.get(name).set(property, descriptor);\n        return;\n    }\n    let toBeWrapped = new Map$5([ [ property, descriptor ] ]);\n    properties.set(name, toBeWrapped);\n    Object$8.defineProperty(object, name, {\n        get: () => value,\n        set(newValue) {\n            value = newValue;\n            if (value && (typeof value == \"object\" || typeof value == \"function\")) {\n                for (let [prop, desc] of toBeWrapped) wrapPropertyAccess(value, prop, desc);\n            }\n        },\n        configurable: true\n    });\n}\n\n/**\n * Overrides the `onerror` handler to discard tagged error messages from our\n * property wrapping.\n *\n * @param {string} magic The magic string that tags the error message.\n * @private\n */ function overrideOnError(magic) {\n    let prev = onerror();\n    onerror(((...args) => {\n        let message = args.length && args[0];\n        if (typeof message == \"string\" && $(message).includes(magic)) return true;\n        if (typeof prev == \"function\") return apply$2(prev, this, args);\n    }));\n}\n\n/**\n * Patches a property on the `context` object to abort execution when the\n * property is read.\n *\n * @param {string} loggingPrefix A string with which we prefix the logs.\n * @param {Window} context The window object whose property we patch.\n * @param {string} property The name of the property.\n * @private\n */ function abortOnRead(loggingPrefix, context, property) {\n    let debugLog = getDebugger(loggingPrefix);\n    if (!property) {\n        debugLog(\"no property to abort on read\");\n        return;\n    }\n    let rid = randomId();\n    function abort() {\n        debugLog(`${property} access aborted`);\n        throw new ReferenceError$2(rid);\n    }\n    debugLog(`aborting on ${property} access`);\n    wrapPropertyAccess(context, property, {\n        get: abort,\n        set() {}\n    });\n    overrideOnError(rid);\n}\n\n/**\n * Patches a property on the `context` object to abort execution when the\n * property is written.\n *\n * @param {string} loggingPrefix A string with which we prefix the logs.\n * @param {Window} context The window object whose property we patch.\n * @param {string} property The name of the property.\n * @private\n */ function abortOnWrite(loggingPrefix, context, property) {\n    let debugLog = getDebugger(loggingPrefix);\n    if (!property) {\n        debugLog(\"no property to abort on write\");\n        return;\n    }\n    let rid = randomId();\n    function abort() {\n        debugLog(`setting ${property} aborted`);\n        throw new ReferenceError$2(rid);\n    }\n    debugLog(`aborting when setting ${property}`);\n    wrapPropertyAccess(context, property, {\n        set: abort\n    });\n    overrideOnError(rid);\n}\n\n/**\n * Patches a list of properties on the iframes' window object to abort execution\n * when the property is read/written.\n *\n * @param {...string} properties The list with the properties.\n * @param {boolean?} [abortRead=false] Should abort on read option.\n * @param {boolean?} [abortWrite=false] Should abort on write option.\n * @private\n */ function abortOnIframe(properties, abortRead = false, abortWrite = false) {\n    let abortedIframes = variables$2.abortedIframes;\n    let iframePropertiesToAbort = variables$2.iframePropertiesToAbort;\n    for (let frame of Array$1.from(window.frames)) {\n        if (abortedIframes.has(frame)) {\n            for (let property of properties) {\n                if (abortRead) abortedIframes.get(frame).read.add(property);\n                if (abortWrite) abortedIframes.get(frame).write.add(property);\n            }\n        }\n    }\n    for (let property of properties) {\n        if (abortRead) iframePropertiesToAbort.read.add(property);\n        if (abortWrite) iframePropertiesToAbort.write.add(property);\n    }\n    queryAndProxyIframe();\n    if (!abortedIframes.has(document)) {\n        abortedIframes.set(document, true);\n        addHooksOnDomAdditions(queryAndProxyIframe);\n    }\n    function queryAndProxyIframe() {\n        for (let frame of Array$1.from(window.frames)) {\n            if (!abortedIframes.has(frame)) {\n                abortedIframes.set(frame, {\n                    read: new Set$1(iframePropertiesToAbort.read),\n                    write: new Set$1(iframePropertiesToAbort.write)\n                });\n            }\n            let readProps = abortedIframes.get(frame).read;\n            if (readProps.size > 0) {\n                let props = Array$1.from(readProps);\n                readProps.clear();\n                for (let property of props) abortOnRead(\"abort-on-iframe-property-read\", frame, property);\n            }\n            let writeProps = abortedIframes.get(frame).write;\n            if (writeProps.size > 0) {\n                let props = Array$1.from(writeProps);\n                writeProps.clear();\n                for (let property of props) abortOnWrite(\"abort-on-iframe-property-write\", frame, property);\n            }\n        }\n    }\n}\n\n/**\n * Patches the native functions which are responsible with adding Nodes to DOM.\n * Adds a hook at right after the addition.\n *\n * @param {function} endCallback The list with the properties.\n * @private\n */ function addHooksOnDomAdditions(endCallback) {\n    let descriptor;\n    wrapAccess(NodeProto$1, [ \"appendChild\", \"insertBefore\", \"replaceChild\" ]);\n    wrapAccess(ElementProto$2, [ \"append\", \"prepend\", \"replaceWith\", \"after\", \"before\", \"insertAdjacentElement\", \"insertAdjacentHTML\" ]);\n    descriptor = getInnerHTMLDescriptor(ElementProto$2, \"innerHTML\");\n    wrapPropertyAccess(ElementProto$2, \"innerHTML\", descriptor);\n    descriptor = getInnerHTMLDescriptor(ElementProto$2, \"outerHTML\");\n    wrapPropertyAccess(ElementProto$2, \"outerHTML\", descriptor);\n    function wrapAccess(prototype, names) {\n        for (let name of names) {\n            let desc = getAppendChildDescriptor(prototype, name);\n            wrapPropertyAccess(prototype, name, desc);\n        }\n    }\n    function getAppendChildDescriptor(target, property) {\n        let currentValue = target[property];\n        return {\n            get() {\n                return function(...args) {\n                    let result;\n                    result = apply$2(currentValue, this, args);\n                    endCallback && endCallback();\n                    return result;\n                };\n            }\n        };\n    }\n    function getInnerHTMLDescriptor(target, property) {\n        let desc = Object$8.getOwnPropertyDescriptor(target, property);\n        let {set: prevSetter} = desc || {};\n        return {\n            set(val) {\n                let result;\n                result = call(prevSetter, this, val);\n                endCallback && endCallback();\n                return result;\n            }\n        };\n    }\n}\n\nlet {Object: NativeObject} = window;\n\nfunction findOwner(root, path) {\n    if (!(root instanceof NativeObject)) return;\n    let object = root;\n    let chain = $(path).split(\".\");\n    if (chain.length === 0) return;\n    for (let i = 0; i < chain.length - 1; i++) {\n        let prop = chain[i];\n        if (!hasOwnProperty(object, prop)) return;\n        object = object[prop];\n        if (!(object instanceof NativeObject)) return;\n    }\n    let prop = chain[chain.length - 1];\n    if (hasOwnProperty(object, prop)) return [ object, prop ];\n}\n\nconst decimals = $(/^\\d+$/);\n\nfunction overrideValue(value) {\n    switch (value) {\n      case \"false\":\n        return false;\n\n      case \"true\":\n        return true;\n\n      case \"null\":\n        return null;\n\n      case \"noopFunc\":\n        return () => {};\n\n      case \"trueFunc\":\n        return () => true;\n\n      case \"falseFunc\":\n        return () => false;\n\n      case \"emptyArray\":\n        return [];\n\n      case \"emptyObj\":\n        return {};\n\n      case \"undefined\":\n        return void 0;\n\n      case \"\":\n        return value;\n\n      default:\n        if (decimals.test(value)) return parseFloat(value);\n        throw new Error$7(\"[override-property-read snippet]: \" + `Value \"${value}\" is not valid.`);\n    }\n}\n\nlet {HTMLScriptElement: HTMLScriptElement$1, Object: Object$7, ReferenceError: ReferenceError$1} = $(window);\n\nlet Script = Object$7.getPrototypeOf(HTMLScriptElement$1);\n\n/**\n * Aborts the execution of an inline script.\n * @alias module:content/snippets.abort-current-inline-script\n *\n * @param {string} api API function or property name to anchor on.\n * @param {?string} [search] If specified, only scripts containing the given\n *   string are prevented from executing. If the string begins and ends with a\n *   slash (`/`), the text in between is treated as a regular expression.\n *\n * @since Adblock Plus 3.4.3\n */ function abortCurrentInlineScript(api, search = null) {\n    let re = search ? toRegExp(search) : null;\n    let rid = randomId();\n    let us = $(document).currentScript;\n    let object = window;\n    let path = $(api).split(\".\");\n    let name = $(path).pop();\n    for (let node of $(path)) {\n        object = object[node];\n        if (!object || !(typeof object == \"object\" || typeof object == \"function\")) return;\n    }\n    let {get: prevGetter, set: prevSetter} = Object$7.getOwnPropertyDescriptor(object, name) || {};\n    let currentValue = object[name];\n    let abort = () => {\n        let element = $(document).currentScript;\n        if (element instanceof Script && $(element, \"HTMLScriptElement\").src == \"\" && element != us && (!re || re.test($(element).textContent))) throw new ReferenceError$1(rid);\n    };\n    let descriptor = {\n        get() {\n            abort();\n            if (prevGetter) return call(prevGetter, this);\n            return currentValue;\n        },\n        set(value) {\n            abort();\n            if (prevSetter) call(prevSetter, this, value); else currentValue = value;\n        }\n    };\n    wrapPropertyAccess(object, name, descriptor);\n    overrideOnError(rid);\n}\n\n/**\n * Patches a list of properties on the iframes' window object to abort execution\n * when the property is read.\n *\n * No error is printed to the console.\n * @alias module:content/snippets.abort-on-iframe-property-read\n *\n * @param {...string} properties The list with the properties.\n *\n * @since Adblock Plus 3.10.1\n */ function abortOnIframePropertyRead(...properties) {\n    abortOnIframe(properties, true, false);\n}\n\n/**\n * Patches a list of properties on the iframes' window object to abort execution\n * when the property is written.\n *\n * No error is printed to the console.\n * @alias module:content/snippets.abort-on-iframe-property-write\n *\n * @param {...string} properties The list with the properties.\n *\n * @since Adblock Plus 3.10.1\n */ function abortOnIframePropertyWrite(...properties) {\n    abortOnIframe(properties, false, true);\n}\n\n/**\n * Patches a property on the window object to abort execution when the\n * property is read.\n *\n * No error is printed to the console.\n *\n * The idea originates from\n * [uBlock Origin](https://github.com/uBlockOrigin/uAssets/blob/80b195436f8f8d78ba713237bfc268ecfc9d9d2b/filters/resources.txt#L1703).\n * @alias module:content/snippets.abort-on-property-read\n *\n * @param {string} property The name of the property.\n *\n * @since Adblock Plus 3.4.1\n */ function abortOnPropertyRead(property) {\n    abortOnRead(\"abort-on-property-read\", window, property);\n}\n\n/**\n * Patches a property on the window object to abort execution when the\n * property is written.\n *\n * No error is printed to the console.\n *\n * The idea originates from\n * [uBlock Origin](https://github.com/uBlockOrigin/uAssets/blob/80b195436f8f8d78ba713237bfc268ecfc9d9d2b/filters/resources.txt#L1671).\n * @alias module:content/snippets.abort-on-property-write\n *\n * @param {string} property The name of the property.\n *\n * @since Adblock Plus 3.4.3\n */ function abortOnPropertyWrite(property) {\n    abortOnWrite(\"abort-on-property-write\", window, property);\n}\n\nlet {Error: Error$6} = $(window);\n\nlet {cookie: documentCookies} = accessor(document);\n\n/**\n * Removes a specific cookie by setting it's expiration date in the past.\n * @alias module:content/snippets.cookie-remover\n *\n * @param {string} cookie The name of the cookie that we want removed.\n * If the string begins and ends with a slash (`/`),\n * the text in between is treated as a regular expression.\n *\n * @since Adblock Plus 3.11.2\n */ function cookieRemover(cookie) {\n    if (!cookie) throw new Error$6(\"[cookie-remover snippet]: No cookie to remove.\");\n    let debugLog = getDebugger(\"cookie-remover\");\n    let re = toRegExp(cookie);\n    if (!$(/^http|^about/).test(location.protocol)) {\n        debugLog(\"Snippet only works for http or https and about.\");\n        return;\n    }\n    debugLog(\"Parsing cookies for matches\");\n    for (const pair of $(getCookieMatches())) {\n        let $hostname = $(location.hostname);\n        let name = $(pair).split(\"=\")[0];\n        let expires = \"expires=Thu, 01 Jan 1970 00:00:00 GMT\";\n        let path = \"path=/\";\n        let domain = \"domain=\" + $hostname.slice($hostname.indexOf(\".\") + 1);\n        documentCookies(`${$(name).trim()}=;${expires};${path};${domain}`);\n        debugLog(`Set expiration date on ${name}`);\n    }\n    function getCookieMatches() {\n        const arr = $(documentCookies()).split(\";\");\n        return arr.filter((str => re.test($(str).split(\"=\")[0])));\n    }\n}\n\nlet {document: document$1, getComputedStyle: getComputedStyle, isExtensionContext: isExtensionContext, variables: variables$1, Array: Array, MutationObserver: MutationObserver$2, Object: Object$6, XPathEvaluator: XPathEvaluator, XPathExpression: XPathExpression, XPathResult: XPathResult} = $(window);\n\nlet {querySelectorAll: querySelectorAll} = document$1;\n\nlet $$ = querySelectorAll && bind(querySelectorAll, document$1);\n\nconst {assign: assign, setPrototypeOf: setPrototypeOf} = Object$6;\n\nclass $XPathExpression extends XPathExpression {\n    evaluate(...args) {\n        return setPrototypeOf(apply$2(super.evaluate, this, args), XPathResult.prototype);\n    }\n}\n\nclass $XPathEvaluator extends XPathEvaluator {\n    createExpression(...args) {\n        return setPrototypeOf(apply$2(super.createExpression, this, args), $XPathExpression.prototype);\n    }\n}\n\n/**\n * Hides an HTML element by setting its `style` attribute to\n * `display: none !important`.\n *\n * @param {HTMLElement} element The HTML element to hide.\n * @private\n */ function hideElement(element) {\n    if (variables$1.hidden.has(element)) return;\n    notifyElementHidden(element);\n    variables$1.hidden.add(element);\n    let {style: style} = $(element);\n    let $style = $(style, \"CSSStyleDeclaration\");\n    let properties = $([]);\n    let {debugCSSProperties: debugCSSProperties} = libEnvironment;\n    for (let [key, value] of debugCSSProperties || [ [ \"display\", \"none\" ] ]) {\n        $style.setProperty(key, value, \"important\");\n        properties.push([ key, $style.getPropertyValue(key) ]);\n    }\n    new MutationObserver$2((() => {\n        for (let [key, value] of properties) {\n            let propertyValue = $style.getPropertyValue(key);\n            let propertyPriority = $style.getPropertyPriority(key);\n            if (propertyValue != value || propertyPriority != \"important\") $style.setProperty(key, value, \"important\");\n        }\n    })).observe(element, {\n        attributes: true,\n        attributeFilter: [ \"style\" ]\n    });\n}\n\n/**\n * Notifies the current contentScript that a new element has been hidden.\n * This is done by calling the globally available `checkElement` function\n * and passing the element.\n *\n * @param {HTMLElement} element The HTML element that was hidden.\n * @private\n */ function notifyElementHidden(element) {\n    if (isExtensionContext && typeof checkElement === \"function\") checkElement(element);\n}\n\n/**\n * A callback function to be applied to a node.\n * @callback queryAndApplyCallback\n * @param {Node} node\n * @private\n */\n/**\n * The query function. Accepts a callback function\n * which will be called for every node resulted from querying the document.\n * @callback queryAndApply\n * @param {queryAndApplyCallback} cb\n * @private\n */\n/**\n * Given a CSS or Xpath selector, returns a query function.\n * @param {string} selector A CSS selector or a Xpath selector which must be\n * described with the following syntax: `xpath(the_actual_selector)`\n * @returns {queryAndApply} The query function. Accepts a callback function\n * which will be called for every node resulted from querying the document.\n * @private\n */ function initQueryAndApply(selector) {\n    let $selector = selector;\n    if ($selector.startsWith(\"xpath(\") && $selector.endsWith(\")\")) {\n        let xpathQuery = $selector.slice(6, -1);\n        let evaluator = new $XPathEvaluator;\n        let expression = evaluator.createExpression(xpathQuery, null);\n        let flag = XPathResult.ORDERED_NODE_SNAPSHOT_TYPE;\n        return cb => {\n            if (!cb) return;\n            let result = expression.evaluate(document$1, flag, null);\n            let {snapshotLength: snapshotLength} = result;\n            for (let i = 0; i < snapshotLength; i++) cb(result.snapshotItem(i));\n        };\n    }\n    return cb => $$(selector).forEach(cb);\n}\n\n/**\n * The query function. Retrieves all the nodes in the DOM matching the\n * provided selector.\n * @callback queryAll\n * @returns {Node[]} An array containing all the nodes in the DOM matching\n * the provided selector.\n * @private\n */\n/**\n * Given a CSS or Xpath selector, returns a query function.\n * @param {string} selector A CSS selector or a Xpath selector which must be\n * described with the following syntax: `xpath(the_actual_selector)`\n * @returns {queryAll} The query function. Retrieves all the nodes in the DOM\n * matching the provided selector.\n * @private\n */ function initQueryAll(selector) {\n    let $selector = selector;\n    if ($selector.startsWith(\"xpath(\") && $selector.endsWith(\")\")) {\n        let queryAndApply = initQueryAndApply(selector);\n        return () => {\n            let elements = $([]);\n            queryAndApply((e => elements.push(e)));\n            return elements;\n        };\n    }\n    return () => Array.from($$(selector));\n}\n\nlet {ELEMENT_NODE: ELEMENT_NODE, TEXT_NODE: TEXT_NODE, prototype: NodeProto} = Node;\n\nlet {prototype: ElementProto$1} = Element;\n\nlet {prototype: HTMLElementProto} = HTMLElement;\n\nlet {console: console$2, variables: variables, DOMParser: DOMParser, Error: Error$5, MutationObserver: MutationObserver$1, Object: Object$5, ReferenceError: ReferenceError} = $(window);\n\nlet {getOwnPropertyDescriptor: getOwnPropertyDescriptor} = Object$5;\n\n/**\n * Freezes a DOM element so it prevents adding new nodes inside it.\n * @alias module:content/snippets.freeze-element\n *\n * @param {string} selector The CSS selector for the parent element that\n *   we want to freeze\n * @param {string?} [options] A single parameter for snippet's options.\n *   A string containing all the options we want to pass, each of them\n *   separated by a plus character (`+`). Empty single quotes if none (`''`).\n *   Available options:\n *   **subtree** (if we want to freeze all the element's children as well);\n *   **abort** (throw an error every time an child element gets added);\n * @param {string?} [exceptions] An array of regex/selectors used to specify\n *   the nodes we don't want to prevent being added.\n *   Each array item can be:\n *   **selector** (targeting Element nodes);\n *   **regex** (targeting Text nodes, identified by slash);\n *\n * @since Adblock Plus 3.9.5\n */ function freezeElement(selector, options = \"\", ...exceptions) {\n    let observer;\n    let subtree = false;\n    let shouldAbort = false;\n    let exceptionSelectors = $(exceptions).filter((e => !isRegex(e)));\n    let regexExceptions = $(exceptions).filter((e => isRegex(e))).map(toRegExp);\n    let rid = randomId();\n    let targetNodes;\n    let queryAll = initQueryAll(selector);\n    checkOptions();\n    let data = {\n        selector: selector,\n        shouldAbort: shouldAbort,\n        rid: rid,\n        exceptionSelectors: exceptionSelectors,\n        regexExceptions: regexExceptions,\n        changeId: 0\n    };\n    if (!variables.frozen.has(document)) {\n        variables.frozen.set(document, true);\n        proxyNativeProperties();\n    }\n    observer = new MutationObserver$1(searchAndAttach);\n    observer.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    searchAndAttach();\n    function isRegex(s) {\n        return s.length >= 2 && s[0] == \"/\" && s[s.length - 1] == \"/\";\n    }\n    function checkOptions() {\n        let optionsChunks = $(options).split(\"+\");\n        if (optionsChunks.length === 1 && optionsChunks[0] === \"\") optionsChunks = [];\n        for (let chunk of optionsChunks) {\n            switch (chunk) {\n              case \"subtree\":\n                subtree = true;\n                break;\n\n              case \"abort\":\n                shouldAbort = true;\n                break;\n\n              default:\n                throw new Error$5(\"[freeze] Unknown option passed to the snippet.\" + \" [selector]: \" + selector + \" [option]: \" + chunk);\n            }\n        }\n    }\n    function proxyNativeProperties() {\n        let descriptor;\n        descriptor = getAppendChildDescriptor(NodeProto, \"appendChild\", isFrozen, getSnippetData);\n        wrapPropertyAccess(NodeProto, \"appendChild\", descriptor);\n        descriptor = getAppendChildDescriptor(NodeProto, \"insertBefore\", isFrozen, getSnippetData);\n        wrapPropertyAccess(NodeProto, \"insertBefore\", descriptor);\n        descriptor = getAppendChildDescriptor(NodeProto, \"replaceChild\", isFrozen, getSnippetData);\n        wrapPropertyAccess(NodeProto, \"replaceChild\", descriptor);\n        descriptor = getAppendDescriptor(ElementProto$1, \"append\", isFrozen, getSnippetData);\n        wrapPropertyAccess(ElementProto$1, \"append\", descriptor);\n        descriptor = getAppendDescriptor(ElementProto$1, \"prepend\", isFrozen, getSnippetData);\n        wrapPropertyAccess(ElementProto$1, \"prepend\", descriptor);\n        descriptor = getAppendDescriptor(ElementProto$1, \"replaceWith\", isFrozenOrHasFrozenParent, getSnippetDataFromNodeOrParent);\n        wrapPropertyAccess(ElementProto$1, \"replaceWith\", descriptor);\n        descriptor = getAppendDescriptor(ElementProto$1, \"after\", isFrozenOrHasFrozenParent, getSnippetDataFromNodeOrParent);\n        wrapPropertyAccess(ElementProto$1, \"after\", descriptor);\n        descriptor = getAppendDescriptor(ElementProto$1, \"before\", isFrozenOrHasFrozenParent, getSnippetDataFromNodeOrParent);\n        wrapPropertyAccess(ElementProto$1, \"before\", descriptor);\n        descriptor = getInsertAdjacentDescriptor(ElementProto$1, \"insertAdjacentElement\", isFrozenAndInsideTarget, getSnippetDataBasedOnTarget);\n        wrapPropertyAccess(ElementProto$1, \"insertAdjacentElement\", descriptor);\n        descriptor = getInsertAdjacentDescriptor(ElementProto$1, \"insertAdjacentHTML\", isFrozenAndInsideTarget, getSnippetDataBasedOnTarget);\n        wrapPropertyAccess(ElementProto$1, \"insertAdjacentHTML\", descriptor);\n        descriptor = getInsertAdjacentDescriptor(ElementProto$1, \"insertAdjacentText\", isFrozenAndInsideTarget, getSnippetDataBasedOnTarget);\n        wrapPropertyAccess(ElementProto$1, \"insertAdjacentText\", descriptor);\n        descriptor = getInnerHTMLDescriptor(ElementProto$1, \"innerHTML\", isFrozen, getSnippetData);\n        wrapPropertyAccess(ElementProto$1, \"innerHTML\", descriptor);\n        descriptor = getInnerHTMLDescriptor(ElementProto$1, \"outerHTML\", isFrozenOrHasFrozenParent, getSnippetDataFromNodeOrParent);\n        wrapPropertyAccess(ElementProto$1, \"outerHTML\", descriptor);\n        descriptor = getTextContentDescriptor(NodeProto, \"textContent\", isFrozen, getSnippetData);\n        wrapPropertyAccess(NodeProto, \"textContent\", descriptor);\n        descriptor = getTextContentDescriptor(HTMLElementProto, \"innerText\", isFrozen, getSnippetData);\n        wrapPropertyAccess(HTMLElementProto, \"innerText\", descriptor);\n        descriptor = getTextContentDescriptor(NodeProto, \"nodeValue\", isFrozen, getSnippetData);\n        wrapPropertyAccess(NodeProto, \"nodeValue\", descriptor);\n        function isFrozen(node) {\n            return node && variables.frozen.has(node);\n        }\n        function isFrozenOrHasFrozenParent(node) {\n            try {\n                return node && (variables.frozen.has(node) || variables.frozen.has($(node).parentNode));\n            } catch (error) {\n                return false;\n            }\n        }\n        function isFrozenAndInsideTarget(node, isInsideTarget) {\n            try {\n                return node && (variables.frozen.has(node) && isInsideTarget || variables.frozen.has($(node).parentNode) && !isInsideTarget);\n            } catch (error) {\n                return false;\n            }\n        }\n        function getSnippetData(node) {\n            return variables.frozen.get(node);\n        }\n        function getSnippetDataFromNodeOrParent(node) {\n            try {\n                if (variables.frozen.has(node)) return variables.frozen.get(node);\n                let parent = $(node).parentNode;\n                return variables.frozen.get(parent);\n            } catch (error) {}\n        }\n        function getSnippetDataBasedOnTarget(node, isInsideTarget) {\n            try {\n                if (variables.frozen.has(node) && isInsideTarget) return variables.frozen.get(node);\n                let parent = $(node).parentNode;\n                return variables.frozen.get(parent);\n            } catch (error) {}\n        }\n    }\n    function searchAndAttach() {\n        targetNodes = queryAll();\n        markNodes(targetNodes, false);\n    }\n    function markNodes(nodes, isChild = true) {\n        for (let node of nodes) {\n            if (!variables.frozen.has(node)) {\n                variables.frozen.set(node, data);\n                if (!isChild && subtree) {\n                    new MutationObserver$1((mutationsList => {\n                        for (let mutation of $(mutationsList)) markNodes($(mutation, \"MutationRecord\").addedNodes);\n                    })).observe(node, {\n                        childList: true,\n                        subtree: true\n                    });\n                }\n                if (subtree && $(node).nodeType === ELEMENT_NODE) markNodes($(node).childNodes);\n            }\n        }\n    }\n    function logPrefixed(id, ...args) {\n        log(`[freeze][${id}] `, ...args);\n    }\n    function logChange(nodeOrDOMString, target, property, snippetData) {\n        let targetSelector = snippetData.selector;\n        let chgId = snippetData.changeId;\n        let isDOMString = typeof nodeOrDOMString == \"string\";\n        let action = snippetData.shouldAbort ? \"aborting\" : \"watching\";\n        console$2.groupCollapsed(`[freeze][${chgId}] ${action}: ${targetSelector}`);\n        switch (property) {\n          case \"appendChild\":\n          case \"append\":\n          case \"prepend\":\n          case \"insertBefore\":\n          case \"replaceChild\":\n          case \"insertAdjacentElement\":\n          case \"insertAdjacentHTML\":\n          case \"insertAdjacentText\":\n          case \"innerHTML\":\n          case \"outerHTML\":\n            logPrefixed(chgId, isDOMString ? \"text: \" : \"node: \", nodeOrDOMString);\n            logPrefixed(chgId, \"added to node: \", target);\n            break;\n\n          case \"replaceWith\":\n          case \"after\":\n          case \"before\":\n            logPrefixed(chgId, isDOMString ? \"text: \" : \"node: \", nodeOrDOMString);\n            logPrefixed(chgId, \"added to node: \", $(target).parentNode);\n            break;\n\n          case \"textContent\":\n          case \"innerText\":\n          case \"nodeValue\":\n            logPrefixed(chgId, \"content of node: \", target);\n            logPrefixed(chgId, \"changed to: \", nodeOrDOMString);\n            break;\n        }\n        logPrefixed(chgId, `using the function \"${property}\"`);\n        console$2.groupEnd();\n        snippetData.changeId++;\n    }\n    function isExceptionNode(element, expSelectors) {\n        if (expSelectors) {\n            let $element = $(element);\n            for (let exception of expSelectors) {\n                if ($element.matches(exception)) return true;\n            }\n        }\n        return false;\n    }\n    function isExceptionText(string, regExceptions) {\n        if (regExceptions) {\n            for (let exception of regExceptions) {\n                if (exception.test(string)) return true;\n            }\n        }\n        return false;\n    }\n    function abort(id) {\n        throw new ReferenceError(id);\n    }\n    function checkHTML(htmlText, parent, property, snippetData) {\n        let domparser = new DOMParser;\n        let {body: body} = $(domparser.parseFromString(htmlText, \"text/html\"));\n        let nodes = $(body).childNodes;\n        let accepted = checkMultiple(nodes, parent, property, snippetData);\n        let content = $(accepted).map((node => {\n            switch ($(node).nodeType) {\n              case ELEMENT_NODE:\n                return $(node).outerHTML;\n\n              case TEXT_NODE:\n                return $(node).textContent;\n\n              default:\n                return \"\";\n            }\n        }));\n        return content.join(\"\");\n    }\n    function checkMultiple(nodesOrDOMStrings, parent, property, snippetData) {\n        let accepted = $([]);\n        for (let nodeOrDOMString of nodesOrDOMStrings) {\n            if (checkShouldInsert(nodeOrDOMString, parent, property, snippetData)) accepted.push(nodeOrDOMString);\n        }\n        return accepted;\n    }\n    function checkShouldInsert(nodeOrDOMString, parent, property, snippetData) {\n        let aborting = snippetData.shouldAbort;\n        let regExceptions = snippetData.regexExceptions;\n        let expSelectors = snippetData.exceptionSelectors;\n        let id = snippetData.rid;\n        if (typeof nodeOrDOMString == \"string\") {\n            let domString = nodeOrDOMString;\n            if (isExceptionText(domString, regExceptions)) return true;\n            if (debug()) logChange(domString, parent, property, snippetData);\n            if (aborting) abort(id);\n            return debug();\n        }\n        let node = nodeOrDOMString;\n        switch ($(node).nodeType) {\n          case ELEMENT_NODE:\n            if (isExceptionNode(node, expSelectors)) return true;\n            if (aborting) {\n                if (debug()) logChange(node, parent, property, snippetData);\n                abort(id);\n            }\n            if (debug()) {\n                hideElement(node);\n                logChange(node, parent, property, snippetData);\n                return true;\n            }\n            return false;\n\n          case TEXT_NODE:\n            if (isExceptionText($(node).textContent, regExceptions)) return true;\n            if (debug()) logChange(node, parent, property, snippetData);\n            if (aborting) abort(id);\n            return false;\n\n          default:\n            return true;\n        }\n    }\n    function getAppendChildDescriptor(target, property, shouldValidate, getSnippetData) {\n        let desc = getOwnPropertyDescriptor(target, property) || {};\n        let origin = desc.get && call(desc.get, target) || desc.value;\n        if (!origin) return;\n        return {\n            get() {\n                return function(...args) {\n                    if (shouldValidate(this)) {\n                        let snippetData = getSnippetData(this);\n                        if (snippetData) {\n                            let incomingNode = args[0];\n                            if (!checkShouldInsert(incomingNode, this, property, snippetData)) return incomingNode;\n                        }\n                    }\n                    return apply$2(origin, this, args);\n                };\n            }\n        };\n    }\n    function getAppendDescriptor(target, property, shouldValidate, getSnippetData) {\n        let desc = getOwnPropertyDescriptor(target, property) || {};\n        let origin = desc.get && call(desc.get, target) || desc.value;\n        if (!origin) return;\n        return {\n            get() {\n                return function(...nodesOrDOMStrings) {\n                    if (!shouldValidate(this)) return apply$2(origin, this, nodesOrDOMStrings);\n                    let snippetData = getSnippetData(this);\n                    if (!snippetData) return apply$2(origin, this, nodesOrDOMStrings);\n                    let accepted = checkMultiple(nodesOrDOMStrings, this, property, snippetData);\n                    if (accepted.length > 0) return apply$2(origin, this, accepted);\n                };\n            }\n        };\n    }\n    function getInsertAdjacentDescriptor(target, property, shouldValidate, getSnippetData) {\n        let desc = getOwnPropertyDescriptor(target, property) || {};\n        let origin = desc.get && call(desc.get, target) || desc.value;\n        if (!origin) return;\n        return {\n            get() {\n                return function(...args) {\n                    let [position, value] = args;\n                    let isInsideTarget = position === \"afterbegin\" || position === \"beforeend\";\n                    if (shouldValidate(this, isInsideTarget)) {\n                        let snippetData = getSnippetData(this, isInsideTarget);\n                        if (snippetData) {\n                            let parent = isInsideTarget ? this : $(this).parentNode;\n                            let finalValue;\n                            switch (property) {\n                              case \"insertAdjacentElement\":\n                                if (!checkShouldInsert(value, parent, property, snippetData)) return value;\n                                break;\n\n                              case \"insertAdjacentHTML\":\n                                finalValue = checkHTML(value, parent, property, snippetData);\n                                if (finalValue) return call(origin, this, position, finalValue);\n                                return;\n\n                              case \"insertAdjacentText\":\n                                if (!checkShouldInsert(value, parent, property, snippetData)) return;\n                                break;\n                            }\n                        }\n                    }\n                    return apply$2(origin, this, args);\n                };\n            }\n        };\n    }\n    function getInnerHTMLDescriptor(target, property, shouldValidate, getSnippetData) {\n        let desc = getOwnPropertyDescriptor(target, property) || {};\n        let {set: prevSetter} = desc;\n        if (!prevSetter) return;\n        return {\n            set(htmlText) {\n                if (!shouldValidate(this)) return call(prevSetter, this, htmlText);\n                let snippetData = getSnippetData(this);\n                if (!snippetData) return call(prevSetter, this, htmlText);\n                let finalValue = checkHTML(htmlText, this, property, snippetData);\n                if (finalValue) return call(prevSetter, this, finalValue);\n            }\n        };\n    }\n    function getTextContentDescriptor(target, property, shouldValidate, getSnippetData) {\n        let desc = getOwnPropertyDescriptor(target, property) || {};\n        let {set: prevSetter} = desc;\n        if (!prevSetter) return;\n        return {\n            set(domString) {\n                if (!shouldValidate(this)) return call(prevSetter, this, domString);\n                let snippetData = getSnippetData(this);\n                if (!snippetData) return call(prevSetter, this, domString);\n                if (checkShouldInsert(domString, this, property, snippetData)) return call(prevSetter, this, domString);\n            }\n        };\n    }\n}\n\n$(window);\n\n/**\n * Returns a function that, when a race is happening, can mark a winner,\n * by invoking all callbacks passed for every other snippet that lost the race.\n * @param {function} lose a callback that, once invoked, will stop the snippet.\n * @returns {function} a callback to invoke whenever a match happens.\n */ function raceWinner(lose) {\n    return noop;\n}\n\nconst {Map: Map$4, MutationObserver: MutationObserver, Object: Object$4, Set: Set, WeakSet: WeakSet$1} = $(window);\n\nlet ElementProto = Element.prototype;\n\nlet {attachShadow: attachShadow} = ElementProto;\n\nlet hiddenShadowRoots = new WeakSet$1;\n\nlet searches = new Map$4;\n\nlet observer = null;\n\n/**\n * Hides any HTML element or one of its ancestors matching a CSS selector if\n * the text content of the element's shadow contains a given string.\n * @alias module:content/snippets.hide-if-shadow-contains\n *\n * @param {string} search The string to look for in every HTML element's\n *   shadow. If the string begins and ends with a slash (`/`), the text in\n *   between is treated as a regular expression.\n * @param {string} selector The CSS selector that an HTML element must match\n *   for it to be hidden.\n *\n * @since Adblock Plus 3.3\n */ function hideIfShadowContains(search, selector = \"*\") {\n    let key = `${search}\\\\${selector}`;\n    if (!searches.has(key)) {\n        searches.set(key, [ toRegExp(search), selector, raceWinner() ]);\n    }\n    if (!observer) {\n        observer = new MutationObserver((records => {\n            let visited = new Set;\n            for (let {target: target} of $(records)) {\n                let parent = $(target).parentNode;\n                while (parent) [target, parent] = [ parent, $(target).parentNode ];\n                if (hiddenShadowRoots.has(target)) continue;\n                if (visited.has(target)) continue;\n                visited.add(target);\n                for (let [re, selfOrParent, win] of searches.values()) {\n                    if (re.test($(target).textContent)) {\n                        let closest = $(target.host).closest(selfOrParent);\n                        if (closest) {\n                            win();\n                            $(target).appendChild(document.createElement(\"style\")).textContent = \":host {display: none !important}\";\n                            hideElement(closest);\n                            hiddenShadowRoots.add(target);\n                        }\n                    }\n                }\n            }\n        }));\n        Object$4.defineProperty(ElementProto, \"attachShadow\", {\n            value: proxy(attachShadow, (function() {\n                let root = apply$2(attachShadow, this, arguments);\n                observer.observe(root, {\n                    childList: true,\n                    characterData: true,\n                    subtree: true\n                });\n                return root;\n            }))\n        });\n    }\n}\n\nconst {Error: Error$4, JSON: JSON$2, Map: Map$3, Object: Object$3} = $(window);\n\nlet paths$1 = null;\n\n/**\n * Traps calls to JSON.parse, and if the result of the parsing is an Object, it\n * will replace specified properties from the result before returning to the\n * caller.\n * @alias module:content/snippets.json-override\n *\n * @param {string} rawOverridePaths A list of space-separated properties\n * to replace.\n * @param {string} value The value to override the properties with.\n * Possible values to override the property with:\n *   undefined\n *   false\n *   true\n *   null\n *   noopFunc    - function with empty body\n *   trueFunc    - function returning true\n *   falseFunc   - function returning false\n *   ''          - empty string\n *   positive decimal integer, no sign, with maximum value of 0x7FFF\n *   emptyArray  - an array with no elements\n *   emptyObject - an object with no properties\n *\n * @param {?string} [rawNeedlePaths] A list of space-separated properties which\n *   must be all present for the pruning to occur.\n * @param {?string} [filter] A string to look for in the raw string,\n * before it's passed to JSON.parse.\n * If no match is found no further search is done on the resulting object.\n * If the string begins and ends with a slash (/),\n * the text in between is treated as a regular expression.\n *\n * @since Adblock Plus 3.11.2\n */ function jsonOverride(rawOverridePaths, value, rawNeedlePaths = \"\", filter = \"\") {\n    if (!rawOverridePaths) throw new Error$4(\"[json-override snippet]: Missing paths to override.\");\n    if (typeof value == \"undefined\") throw new Error$4(\"[json-override snippet]: No value to override with.\");\n    if (!paths$1) {\n        let debugLog = getDebugger(\"json-override\");\n        let {parse: parse} = JSON$2;\n        paths$1 = new Map$3;\n        Object$3.defineProperty(window.JSON, \"parse\", {\n            value: proxy(parse, (function(str) {\n                let result = apply$2(parse, this, arguments);\n                for (let {prune: prune, needle: needle, filter: flt, value: val} of paths$1.values()) {\n                    if (flt && !flt.test(str)) continue;\n                    if ($(needle).some((path => !findOwner(result, path)))) return result;\n                    for (let path of prune) {\n                        let details = findOwner(result, path);\n                        if (typeof details != \"undefined\") {\n                            debugLog(`Found ${path} replaced it with ${val}`);\n                            details[0][details[1]] = overrideValue(val);\n                        }\n                    }\n                }\n                return result;\n            }))\n        });\n        debugLog(\"Wrapped JSON.parse for override\");\n    }\n    paths$1.set(rawOverridePaths, {\n        prune: $(rawOverridePaths).split(/ +/),\n        needle: rawNeedlePaths.length ? $(rawNeedlePaths).split(/ +/) : [],\n        filter: filter ? toRegExp(filter) : null,\n        value: value\n    });\n}\n\nlet {Error: Error$3, JSON: JSON$1, Map: Map$2, Object: Object$2} = $(window);\n\nlet paths = null;\n\n/**\n * Traps calls to JSON.parse, and if the result of the parsing is an Object, it\n * will remove specified properties from the result before returning to the\n * caller.\n *\n * The idea originates from\n * [uBlock Origin](https://github.com/gorhill/uBlock/commit/2fd86a66).\n * @alias module:content/snippets.json-prune\n *\n * @param {string} rawPrunePaths A list of space-separated properties to remove.\n * @param {?string} [rawNeedlePaths] A list of space-separated properties which\n *   must be all present for the pruning to occur.\n *\n * @since Adblock Plus 3.9.0\n */ function jsonPrune(rawPrunePaths, rawNeedlePaths = \"\") {\n    if (!rawPrunePaths) throw new Error$3(\"Missing paths to prune\");\n    if (!paths) {\n        let debugLog = getDebugger(\"json-prune\");\n        let {parse: parse} = JSON$1;\n        paths = new Map$2;\n        Object$2.defineProperty(window.JSON, \"parse\", {\n            value: proxy(parse, (function() {\n                let result = apply$2(parse, this, arguments);\n                for (let {prune: prune, needle: needle} of paths.values()) {\n                    if ($(needle).some((path => !findOwner(result, path)))) return result;\n                    for (let path of prune) {\n                        let details = findOwner(result, path);\n                        if (typeof details != \"undefined\") {\n                            debugLog(`Found ${path} and deleted`);\n                            delete details[0][details[1]];\n                        }\n                    }\n                }\n                return result;\n            }))\n        });\n        debugLog(\"Wrapped JSON.parse for prune\");\n    }\n    paths.set(rawPrunePaths, {\n        prune: $(rawPrunePaths).split(/ +/),\n        needle: rawNeedlePaths.length ? $(rawNeedlePaths).split(/ +/) : []\n    });\n}\n\nlet {Error: Error$2} = $(window);\n\n/**\n * Overrides a property's value on the window object with a set of\n * available properties.\n *\n * Possible values to override the property with:\n *   undefined\n *   false\n *   true\n *   null\n *   noopFunc   - function with empty body\n *   trueFunc   - function returning true\n *   falseFunc  - function returning false\n *   emptyArray  - an array with no elements\n *   emptyObject - an object with no properties\n *   ''         - empty string\n *   positive decimal integer, no sign, with maximum value of 0x7FFF\n *\n * The idea originates from\n * [uBlock Origin](https://github.com/uBlockOrigin/uAssets/blob/80b195436f8f8d78ba713237bfc268ecfc9d9d2b/filters/resources.txt#L2105).\n * @alias module:content/snippets.override-property-read\n *\n * @param {string} property The name of the property.\n * @param {string} value The value to override the property with.\n *\n * @since Adblock Plus 3.9.4\n */ function overridePropertyRead(property, value) {\n    if (!property) {\n        throw new Error$2(\"[override-property-read snippet]: \" + \"No property to override.\");\n    }\n    if (typeof value === \"undefined\") {\n        throw new Error$2(\"[override-property-read snippet]: \" + \"No value to override with.\");\n    }\n    let debugLog = getDebugger(\"override-property-read\");\n    let cValue = overrideValue(value);\n    let newGetter = () => {\n        debugLog(`${property} override done.`);\n        return cValue;\n    };\n    debugLog(`Overriding ${property}.`);\n    wrapPropertyAccess(window, property, {\n        get: newGetter,\n        set() {}\n    });\n}\n\nlet {Error: Error$1, Map: Map$1, Object: Object$1, console: console$1} = $(window);\n\nlet {toString: toString} = Function.prototype;\n\nlet EventTargetProto = EventTarget.prototype;\n\nlet {addEventListener: addEventListener} = EventTargetProto;\n\nlet events = null;\n\n/**\n * Prevents adding event listeners.\n * @alias module:content/snippets.prevent-listener\n *\n * @param {string} event Pattern that matches the type(s) of event\n * we want to prevent. If the string starts and ends with a slash (`/`),\n * the text in between is treated as a regular expression.\n * @param {?string} eventHandler Pattern that matches the event handler's\n * declaration. If the string starts and ends with a slash (`/`),\n * the text in between is treated as a regular expression.\n * @param {?string} selector The CSS selector that the event target must match.\n * If the event target is not an HTML element the event handler is added.\n * @since Adblock Plus 3.11.2\n */ function preventListener(event, eventHandler, selector) {\n    if (!event) throw new Error$1(\"[prevent-listener snippet]: No event type.\");\n    if (!events) {\n        events = new Map$1;\n        let debugLog = getDebugger(\"[prevent]\");\n        Object$1.defineProperty(EventTargetProto, \"addEventListener\", {\n            value: proxy(addEventListener, (function(type, listener) {\n                for (let {evt: evt, handlers: handlers, selectors: selectors} of events.values()) {\n                    if (!evt.test(type)) continue;\n                    let isElement = this instanceof Element;\n                    for (let i = 0; i < handlers.length; i++) {\n                        let handler = handlers[i];\n                        let sel = selectors[i];\n                        let handlerMatch = () => handler.test(call(toString, typeof listener === \"function\" ? listener : listener.handleEvent));\n                        if (handler && !handlerMatch() || sel && !(isElement && $(this).matches(sel))) continue;\n                        if (debug()) {\n                            console$1.groupCollapsed(\"DEBUG [prevent] was successful\");\n                            debugLog(`type: ${type} matching ${evt}`);\n                            debugLog(\"handler:\", listener);\n                            if (handler) debugLog(`matching ${handler}`);\n                            if (sel) debugLog(\"on element: \", this, ` matching ${sel}`);\n                            debugLog(\"was prevented from being added\");\n                            console$1.groupEnd();\n                        }\n                        return;\n                    }\n                }\n                return apply$2(addEventListener, this, arguments);\n            }))\n        });\n        debugLog(\"Wrapped addEventListener\");\n    }\n    if (!events.has(event)) events.set(event, {\n        evt: toRegExp(event),\n        handlers: [],\n        selectors: []\n    });\n    let {handlers: handlers, selectors: selectors} = events.get(event);\n    handlers.push(eventHandler ? toRegExp(eventHandler) : null);\n    selectors.push(selector);\n}\n\nlet {URL: URL, fetch: fetch} = $(window);\n\nlet {delete: deleteParam} = caller(URLSearchParams.prototype);\n\nlet parameters;\n\n/**\n * Strips a query string parameter from `fetch()` calls.\n * @alias module:content/snippets.strip-fetch-query-parameter\n *\n * @param {string} name The name of the parameter.\n * @param {?string} [urlPattern] An optional pattern that the URL must match.\n *\n * @since Adblock Plus 3.5.1\n */ function stripFetchQueryParameter(name, urlPattern = null) {\n    if (!parameters) {\n        parameters = new Map;\n        window.fetch = proxy(fetch, ((...args) => {\n            let [source] = args;\n            if (typeof source === \"string\") {\n                let url = new URL(source);\n                for (let [key, reg] of parameters) {\n                    if (!reg || reg.test(source)) {\n                        deleteParam(url.searchParams, key);\n                        args[0] = url.href;\n                    }\n                }\n            }\n            return apply$2(fetch, self, args);\n        }));\n    }\n    parameters.set(name, urlPattern && toRegExp(urlPattern));\n}\n\n/**\n * Similar to `log`, but does the logging in the context of the document rather\n * than the content script.\n *\n * This may be used for testing and debugging, especially to verify that the\n * injection of snippets into the document is working without any errors.\n * @alias module:content/snippets.trace\n *\n * @param {...*} [args] The arguments to log.\n *\n * @since Adblock Plus 3.3\n */ function trace(...args) {\n    apply$2(log, null, args);\n}\n\nconst injectedSnippetsList = [ \"abort-current-inline-script\", \"abort-on-iframe-property-read\", \"abort-on-iframe-property-write\", \"abort-on-property-read\", \"abort-on-property-write\", \"cookie-remover\", \"debug\", \"freeze-element\", \"hide-if-shadow-contains\", \"json-override\", \"json-prune\", \"override-property-read\", \"prevent-listener\", \"strip-fetch-query-parameter\", \"trace\" ];\n\nconst injectedSnippetsCallbacks = [ abortCurrentInlineScript, abortOnIframePropertyRead, abortOnIframePropertyWrite, abortOnPropertyRead, abortOnPropertyWrite, cookieRemover, setDebug, freezeElement, hideIfShadowContains, jsonOverride, jsonPrune, overridePropertyRead, preventListener, stripFetchQueryParameter, trace ];\n\nconst snippets = {};\n\nfor (let i = 0, {length: length} = injectedSnippetsList; i < length; i++) snippets[injectedSnippetsList[i]] = injectedSnippetsCallbacks[i];\n\nsnippets.trace();\n","isolatedCode":"/**\n * This file is part of eyeo's Anti-Circumvention Snippets module (@eyeo/snippets),\n * Copyright (C) 2006-present eyeo GmbH\n *\n * @eyeo/snippets is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 3 as\n * published by the Free Software Foundation.\n *\n * @eyeo/snippets is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with @eyeo/snippets.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nconst $$1 = Proxy;\n\nconst {apply: a, bind: b, call: c} = Function;\n\nconst apply$2 = c.bind(a);\n\nconst bind = c.bind(b);\n\nconst call = c.bind(c);\n\nconst callerHandler = {\n    get(target, name) {\n        return bind(c, target[name]);\n    }\n};\n\nconst caller = target => new $$1(target, callerHandler);\n\nconst handler$1 = {\n    get(target, name) {\n        return bind(target[name], target);\n    }\n};\n\nconst bound = target => new $$1(target, handler$1);\n\nconst {assign: assign$1, defineProperties: defineProperties$1, freeze: freeze$1, getOwnPropertyDescriptor: getOwnPropertyDescriptor$2, getOwnPropertyDescriptors: getOwnPropertyDescriptors$1, getPrototypeOf: getPrototypeOf} = bound(Object);\n\ncaller({});\n\nconst {species: species} = Symbol;\n\nconst handler = {\n    get(target, name) {\n        const Native = target[name];\n        class Secure extends Native {}\n        const proto = getOwnPropertyDescriptors$1(Native.prototype);\n        delete proto.constructor;\n        freeze$1(defineProperties$1(Secure.prototype, proto));\n        const statics = getOwnPropertyDescriptors$1(Native);\n        delete statics.length;\n        delete statics.prototype;\n        statics[species] = {\n            value: Secure\n        };\n        return freeze$1(defineProperties$1(Secure, statics));\n    }\n};\n\nconst secure = target => new $$1(target, handler)\n/**\n * @typedef {object} Environment\n * @property {Array.<Array>} debugCSSProperties Highlighting options.\n * CSS properties to be applied to the targeted element.\n * @property {string} world Target injection world. 'ISOLATED' or 'MAIN'.\n */\n/**\n * A configuration object passed by integrators.\n * @type {Environment}\n * @private\n */;\n\nconst libEnvironment = typeof environment !== \"undefined\" ? environment : {};\n\nif (typeof globalThis === \"undefined\") window.globalThis = window;\n\nconst {apply: apply$1, ownKeys: ownKeys} = bound(Reflect);\n\nconst worldEnvDefined = \"world\" in libEnvironment;\n\nconst isIsolatedWorld = worldEnvDefined && libEnvironment.world === \"ISOLATED\";\n\nconst isMainWorld = worldEnvDefined && libEnvironment.world === \"MAIN\";\n\nconst isChrome = typeof chrome === \"object\" && !!chrome.runtime;\n\nconst isOtherThanChrome = typeof browser === \"object\" && !!browser.runtime;\n\nconst isExtensionContext$4 = !isMainWorld && (isIsolatedWorld || isChrome || isOtherThanChrome);\n\nconst copyIfExtension = value => isExtensionContext$4 ? value : create(value, getOwnPropertyDescriptors(value));\n\nconst {create: create, defineProperties: defineProperties, defineProperty: defineProperty, freeze: freeze, getOwnPropertyDescriptor: getOwnPropertyDescriptor$1, getOwnPropertyDescriptors: getOwnPropertyDescriptors} = bound(Object);\n\nconst invokes = bound(globalThis);\n\nconst classes = isExtensionContext$4 ? globalThis : secure(globalThis);\n\nconst {Map: Map$5, RegExp: RegExp$1, Set: Set, WeakMap: WeakMap$3, WeakSet: WeakSet$7} = classes;\n\nconst augment = (source, target, method = null) => {\n    const known = ownKeys(target);\n    for (const key of ownKeys(source)) {\n        if (known.includes(key)) continue;\n        const descriptor = getOwnPropertyDescriptor$1(source, key);\n        if (method && \"value\" in descriptor) {\n            const {value: value} = descriptor;\n            if (typeof value === \"function\") descriptor.value = method(value);\n        }\n        defineProperty(target, key, descriptor);\n    }\n};\n\nconst primitive = name => {\n    const Super = classes[name];\n    class Class extends Super {}\n    const {toString: toString, valueOf: valueOf} = Super.prototype;\n    defineProperties(Class.prototype, {\n        toString: {\n            value: toString\n        },\n        valueOf: {\n            value: valueOf\n        }\n    });\n    const type = name.toLowerCase();\n    const method = callback => function() {\n        const result = apply$1(callback, this, arguments);\n        return typeof result === type ? new Class(result) : result;\n    };\n    augment(Super, Class, method);\n    augment(Super.prototype, Class.prototype, method);\n    return Class;\n};\n\nconst variables$1 = freeze({\n    frozen: new WeakMap$3,\n    hidden: new WeakSet$7,\n    iframePropertiesToAbort: {\n        read: new Set,\n        write: new Set\n    },\n    abortedIframes: new WeakMap$3\n});\n\nconst startsCapitalized = new RegExp$1(\"^[A-Z]\");\n\nvar env = new Proxy(new Map$5([ [ \"chrome\", isExtensionContext$4 && (isChrome && chrome || isOtherThanChrome && browser) || void 0 ], [ \"isExtensionContext\", isExtensionContext$4 ], [ \"variables\", variables$1 ], [ \"console\", copyIfExtension(console) ], [ \"document\", globalThis.document ], [ \"performance\", copyIfExtension(performance) ], [ \"JSON\", copyIfExtension(JSON) ], [ \"Map\", Map$5 ], [ \"Math\", copyIfExtension(Math) ], [ \"Number\", isExtensionContext$4 ? Number : primitive(\"Number\") ], [ \"RegExp\", RegExp$1 ], [ \"Set\", Set ], [ \"String\", isExtensionContext$4 ? String : primitive(\"String\") ], [ \"WeakMap\", WeakMap$3 ], [ \"WeakSet\", WeakSet$7 ], [ \"MouseEvent\", MouseEvent ] ]), {\n    get(map, key) {\n        if (map.has(key)) return map.get(key);\n        let value = globalThis[key];\n        if (typeof value === \"function\") value = (startsCapitalized.test(key) ? classes : invokes)[key];\n        map.set(key, value);\n        return value;\n    },\n    has(map, key) {\n        return map.has(key);\n    }\n});\n\n/*! (c) Andrea Giammarchi - ISC */ class WeakValue {\n    has() {\n        return false;\n    }\n    set() {}\n}\n\nconst helpers = {\n    WeakSet: WeakSet,\n    WeakMap: WeakMap,\n    WeakValue: WeakValue\n};\n\nconst {apply: apply} = Reflect;\n\nfunction transformOnce(callback) {\n    const {WeakSet: WeakSet, WeakMap: WeakMap, WeakValue: WeakValue} = this || helpers;\n    const ws = new WeakSet;\n    const wm = new WeakMap;\n    const wv = new WeakValue;\n    return function(any) {\n        if (ws.has(any)) return any;\n        if (wm.has(any)) return wm.get(any);\n        if (wv.has(any)) return wv.get(any);\n        const value = apply(callback, this, arguments);\n        ws.add(value);\n        if (value !== any) (typeof any === \"object\" && any ? wm : wv).set(any, value);\n        return value;\n    };\n}\n\nconst {Map: Map$4, WeakMap: WeakMap$2, WeakSet: WeakSet$6, setTimeout: setTimeout$2} = env;\n\nlet cleanup = true;\n\nlet cleanUpCallback = map => {\n    map.clear();\n    cleanup = !cleanup;\n};\n\nvar transformer = transformOnce.bind({\n    WeakMap: WeakMap$2,\n    WeakSet: WeakSet$6,\n    WeakValue: class extends Map$4 {\n        set(key, value) {\n            if (cleanup) {\n                cleanup = !cleanup;\n                setTimeout$2(cleanUpCallback, 0, this);\n            }\n            return super.set(key, value);\n        }\n    }\n});\n\nconst {concat: concat, includes: includes, join: join, reduce: reduce$1, unshift: unshift} = caller([]);\n\nconst {Map: Map$3, WeakMap: WeakMap$1} = secure(globalThis);\n\nconst map$1 = new Map$3;\n\nconst descriptors = target => {\n    const chain = [];\n    let current = target;\n    while (current) {\n        if (map$1.has(current)) unshift(chain, map$1.get(current)); else {\n            const descriptors = getOwnPropertyDescriptors$1(current);\n            map$1.set(current, descriptors);\n            unshift(chain, descriptors);\n        }\n        current = getPrototypeOf(current);\n    }\n    unshift(chain, {});\n    return apply$2(assign$1, null, chain);\n};\n\nconst chain = source => {\n    const target = typeof source === \"function\" ? source.prototype : source;\n    const chained = descriptors(target);\n    const handler = {\n        get(target, key) {\n            if (key in chained) {\n                const {value: value, get: get} = chained[key];\n                if (get) return call(get, target);\n                if (typeof value === \"function\") return bind(value, target);\n            }\n            return target[key];\n        },\n        set(target, key, value) {\n            if (key in chained) {\n                const {set: set} = chained[key];\n                if (set) {\n                    call(set, target, value);\n                    return true;\n                }\n            }\n            target[key] = value;\n            return true;\n        }\n    };\n    return target => new Proxy(target, handler);\n};\n\nconst {isExtensionContext: isExtensionContext$3, Array: Array$3, Number: Number$1, String: String$1, Object: Object$3} = env;\n\nconst {isArray: isArray} = Array$3;\n\nconst {getOwnPropertyDescriptor: getOwnPropertyDescriptor, setPrototypeOf: setPrototypeOf$1} = Object$3;\n\nconst {toString: toString} = Object$3.prototype;\n\nconst {slice: slice} = String$1.prototype;\n\nconst getBrand = value => call(slice, call(toString, value), 8, -1);\n\nconst {get: nodeType} = getOwnPropertyDescriptor(Node.prototype, \"nodeType\");\n\nconst chained = isExtensionContext$3 ? {} : {\n    Attr: chain(Attr),\n    CanvasRenderingContext2D: chain(CanvasRenderingContext2D),\n    CSSStyleDeclaration: chain(CSSStyleDeclaration),\n    Document: chain(Document),\n    Element: chain(Element),\n    HTMLCanvasElement: chain(HTMLCanvasElement),\n    HTMLElement: chain(HTMLElement),\n    HTMLImageElement: chain(HTMLImageElement),\n    HTMLScriptElement: chain(HTMLScriptElement),\n    MutationRecord: chain(MutationRecord),\n    Node: chain(Node),\n    ShadowRoot: chain(ShadowRoot),\n    get CSS2Properties() {\n        return chained.CSSStyleDeclaration;\n    }\n};\n\nconst upgrade = (value, hint) => {\n    if (hint !== \"Element\" && hint in chained) return chained[hint](value);\n    if (isArray(value)) return setPrototypeOf$1(value, Array$3.prototype);\n    const brand = getBrand(value);\n    if (brand in chained) return chained[brand](value);\n    if (brand in env) return setPrototypeOf$1(value, env[brand].prototype);\n    if (\"nodeType\" in value) {\n        switch (call(nodeType, value)) {\n          case 1:\n            if (!(hint in chained)) throw new Error(\"unknown hint \" + hint);\n            return chained[hint](value);\n\n          case 2:\n            return chained.Attr(value);\n\n          case 3:\n            return chained.Node(value);\n\n          case 9:\n            return chained.Document(value);\n        }\n    }\n    throw new Error(\"unknown brand \" + brand);\n};\n\n/** @type {<T>(t:T)=>t} Any value that can be upgraded or wrapped */ var $ = isExtensionContext$3 ? value => value === window ? env : value : transformer(((value, hint = \"Element\") => {\n    if (value === window) return env;\n    switch (typeof value) {\n      case \"object\":\n        return value && upgrade(value, hint);\n\n      case \"string\":\n        return new String$1(value);\n\n      case \"number\":\n        return new Number$1(value);\n\n      default:\n        throw new Error(\"unsupported value\");\n    }\n}));\n\nlet {document: document$1, getComputedStyle: getComputedStyle$4, isExtensionContext: isExtensionContext$2, variables: variables, Array: Array$2, MutationObserver: MutationObserver$8, Object: Object$2, XPathEvaluator: XPathEvaluator, XPathExpression: XPathExpression, XPathResult: XPathResult} = $(window);\n\nlet {querySelectorAll: querySelectorAll} = document$1;\n\nlet $$ = querySelectorAll && bind(querySelectorAll, document$1);\n\nconst {assign: assign, setPrototypeOf: setPrototypeOf} = Object$2;\n\nclass $XPathExpression extends XPathExpression {\n    evaluate(...args) {\n        return setPrototypeOf(apply$2(super.evaluate, this, args), XPathResult.prototype);\n    }\n}\n\nclass $XPathEvaluator extends XPathEvaluator {\n    createExpression(...args) {\n        return setPrototypeOf(apply$2(super.createExpression, this, args), $XPathExpression.prototype);\n    }\n}\n\n/**\n * Hides an HTML element by setting its `style` attribute to\n * `display: none !important`.\n *\n * @param {HTMLElement} element The HTML element to hide.\n * @private\n */ function hideElement(element) {\n    if (variables.hidden.has(element)) return;\n    notifyElementHidden(element);\n    variables.hidden.add(element);\n    let {style: style} = $(element);\n    let $style = $(style, \"CSSStyleDeclaration\");\n    let properties = $([]);\n    let {debugCSSProperties: debugCSSProperties} = libEnvironment;\n    for (let [key, value] of debugCSSProperties || [ [ \"display\", \"none\" ] ]) {\n        $style.setProperty(key, value, \"important\");\n        properties.push([ key, $style.getPropertyValue(key) ]);\n    }\n    new MutationObserver$8((() => {\n        for (let [key, value] of properties) {\n            let propertyValue = $style.getPropertyValue(key);\n            let propertyPriority = $style.getPropertyPriority(key);\n            if (propertyValue != value || propertyPriority != \"important\") $style.setProperty(key, value, \"important\");\n        }\n    })).observe(element, {\n        attributes: true,\n        attributeFilter: [ \"style\" ]\n    });\n}\n\n/**\n * Notifies the current contentScript that a new element has been hidden.\n * This is done by calling the globally available `checkElement` function\n * and passing the element.\n *\n * @param {HTMLElement} element The HTML element that was hidden.\n * @private\n */ function notifyElementHidden(element) {\n    if (isExtensionContext$2 && typeof checkElement === \"function\") checkElement(element);\n}\n\n/**\n * A callback function to be applied to a node.\n * @callback queryAndApplyCallback\n * @param {Node} node\n * @private\n */\n/**\n * The query function. Accepts a callback function\n * which will be called for every node resulted from querying the document.\n * @callback queryAndApply\n * @param {queryAndApplyCallback} cb\n * @private\n */\n/**\n * Given a CSS or Xpath selector, returns a query function.\n * @param {string} selector A CSS selector or a Xpath selector which must be\n * described with the following syntax: `xpath(the_actual_selector)`\n * @returns {queryAndApply} The query function. Accepts a callback function\n * which will be called for every node resulted from querying the document.\n * @private\n */ function initQueryAndApply(selector) {\n    let $selector = selector;\n    if ($selector.startsWith(\"xpath(\") && $selector.endsWith(\")\")) {\n        let xpathQuery = $selector.slice(6, -1);\n        let evaluator = new $XPathEvaluator;\n        let expression = evaluator.createExpression(xpathQuery, null);\n        let flag = XPathResult.ORDERED_NODE_SNAPSHOT_TYPE;\n        return cb => {\n            if (!cb) return;\n            let result = expression.evaluate(document$1, flag, null);\n            let {snapshotLength: snapshotLength} = result;\n            for (let i = 0; i < snapshotLength; i++) cb(result.snapshotItem(i));\n        };\n    }\n    return cb => $$(selector).forEach(cb);\n}\n\n/**\n * Hides any HTML element or one of its ancestors matching a CSS selector if\n * it matches the provided condition.\n *\n * @param {function} match The function that provides the matching condition.\n * @param {string} selector The CSS selector that an HTML element must match\n *   for it to be hidden.\n * @param {?string} [searchSelector] The CSS selector that an HTML element\n *   containing the given string must match. Defaults to the value of the\n *   `selector` argument.\n * @returns {MutationObserver} Augmented MutationObserver object. It has a new\n *   function mo.race added to it. This can be used by the snippets to\n *   disconnect the MutationObserver with the racing mechanism.\n *   Used like: mo.race(raceWinner(() => {mo.disconnect();}));\n * @private\n */ function hideIfMatches(match, selector, searchSelector) {\n    if (searchSelector == null) searchSelector = selector;\n    let won;\n    const callback = () => {\n        for (const element of $$(searchSelector)) {\n            const closest = $(element).closest(selector);\n            if (closest && match(element, closest)) {\n                won();\n                hideElement(closest);\n            }\n        }\n    };\n    return assign(new MutationObserver$8(callback), {\n        race(win) {\n            won = win;\n            this.observe(document$1, {\n                childList: true,\n                characterData: true,\n                subtree: true\n            });\n            callback();\n        }\n    });\n}\n\n/**\n * Check if an element is visible\n *\n * @param {Element} element The element to check visibility of.\n * @param {CSSStyleDeclaration} style The computed style of element.\n * @param {?Element} closest The closest parent to reach.\n * @return {bool} Whether the element is visible.\n * @private\n */ function isVisible(element, style, closest) {\n    let $style = $(style, \"CSSStyleDeclaration\");\n    if ($style.getPropertyValue(\"display\") == \"none\") return false;\n    let visibility = $style.getPropertyValue(\"visibility\");\n    if (visibility == \"hidden\" || visibility == \"collapse\") return false;\n    if (!closest || element == closest) return true;\n    let parent = $(element).parentElement;\n    if (!parent) return true;\n    return isVisible(parent, getComputedStyle$4(parent), closest);\n}\n\n/**\n * Returns the value of the `cssText` property of the object returned by\n * `getComputedStyle` for the given element.\n *\n * If the value of the `cssText` property is blank, this function computes the\n * value out of the properties available in the object.\n *\n * @param {Element} element The element for which to get the computed CSS text.\n *\n * @returns {string} The computed CSS text.\n * @private\n */ function getComputedCSSText(element) {\n    let style = getComputedStyle$4(element);\n    let {cssText: cssText} = style;\n    if (cssText) return cssText;\n    for (let property of style) cssText += `${property}: ${style[property]}; `;\n    return $(cssText).trim();\n}\n\nlet {parseInt: parseInt$1, setTimeout: setTimeout$1, Error: Error$2, MouseEvent: MouseEvent$1, MutationObserver: MutationObserver$7, WeakSet: WeakSet$5} = $(window);\n\n/**\n * Simulate a mouse event on the page.\n * @alias module:content/snippets.simulate-event-poc\n *\n * @param {string} event Pattern that matches the type(s) of event\n * we want to prevent. If the string starts and ends with a slash (`/`),\n * the text in between is treated as a regular expression.\n * @param {string} selector The CSS/Xpath selector that an HTML element must\n * match for the event to be triggered.\n * @param {?string} delay The delay between the moment when the node is inserted\n * and the moment when the event is dispatched.\n *\n * @since Adblock Plus 3.11.2\n */ function simulateEvent(event, selector, delay = \"0\") {\n    if (!event) throw new Error$2(\"[simulate-event snippet]: No event type provided.\");\n    if (!selector) throw new Error$2(\"[simulate-event snippet]: No selector provided.\");\n    let queryAndApply = initQueryAndApply(selector);\n    let delayInMiliseconds = parseInt$1(delay, 10);\n    let dispatchedNodes = new WeakSet$5;\n    let observer = new MutationObserver$7(findNodesAndDispatchEvents);\n    observer.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    findNodesAndDispatchEvents();\n    function findNodesAndDispatchEvents() {\n        queryAndApply((node => {\n            if (!dispatchedNodes.has(node)) {\n                dispatchedNodes.add(node);\n                setTimeout$1((() => {\n                    $(node).dispatchEvent(new MouseEvent$1(event, {\n                        bubbles: true,\n                        cancelable: true\n                    }));\n                }), delayInMiliseconds);\n            }\n        }));\n    }\n}\n\nlet {Math: Math$3, RegExp: RegExp} = $(window);\n\n/**\n * Escapes regular expression special characters in a string.\n *\n * The returned string may be passed to the `RegExp` constructor to match the\n * original string.\n *\n * @param {string} string The string in which to escape special characters.\n *\n * @returns {string} A new string with the special characters escaped.\n * @private\n */ function regexEscape(string) {\n    return $(string).replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n}\n\n/**\n * Converts a given pattern to a regular expression.\n *\n * @param {string} pattern The pattern to convert. If the pattern begins and\n *   ends with a slash (`/`), the text in between is treated as a regular\n *   expression. If the pattern begins with a slash (`/`) and it ends with a\n *   (`/i`), the text in between is treated as case insensitive regular\n *   expression; otherwise the pattern is treated as raw text.\n *\n * @returns {RegExp} A `RegExp` object based on the given pattern.\n * @private\n */ function toRegExp(pattern) {\n    let {length: length} = pattern;\n    if (length > 1 && pattern[0] === \"/\") {\n        let isCaseSensitive = pattern[length - 1] === \"/\";\n        if (isCaseSensitive || length > 2 && $(pattern).endsWith(\"/i\")) {\n            let args = [ $(pattern).slice(1, isCaseSensitive ? -1 : -2) ];\n            if (!isCaseSensitive) args.push(\"i\");\n            return new RegExp(...args);\n        }\n    }\n    return new RegExp(regexEscape(pattern));\n}\n\n/**\n * Generates a random alphanumeric ID consisting of 6 base-36 digits\n * from the range 100000..zzzzzz (both inclusive).\n *\n * @returns {string} The random ID.\n * @private\n */ function randomId() {\n    return $(Math$3.floor(Math$3.random() * 2116316160 + 60466176)).toString(36);\n}\n\n/**\n * Whether debug mode is enabled.\n * @type {boolean}\n * @private\n */ let debugging = false;\n\n/**\n * Tells if the debug mode is inactive.\n * @memberOf module:content/snippets.debug\n * @returns {boolean}\n */ function debug() {\n    return debugging;\n}\n\n/**\n * Enables debug mode.\n * @alias module:content/snippets.debug\n *\n * @example\n * example.com#$#debug; log 'Hello, world!'\n *\n * @since Adblock Plus 3.8\n */ function setDebug() {\n    debugging = true;\n}\n\nconst {console: console$1} = $(window);\n\nconst noop = () => {};\n\n/**\n * Logs its arguments to the console.\n *\n * This may be used for testing and debugging.\n *\n * @alias module:content/snippets.log\n *\n * @param {...*} [args] The arguments to log.\n *\n * @since Adblock Plus 3.3\n */ function log(...args) {\n    if (debug()) $(args).unshift(\"%c DEBUG\", \"font-weight: bold\");\n    console$1.log(...args);\n}\n\n/**\n * Returns a no-op if debugging mode is off, returns a bound log otherwise.\n * @param {string} name the debugger name (first logged value)\n * @returns {function} either a no-op function or the logger one\n */ function getDebugger(name) {\n    return bind(debug() ? log : noop, null, name);\n}\n\nlet {Array: Array$1, Error: Error$1, Map: Map$2, parseInt: parseInt} = $(window);\n\nlet stack = null;\n\nlet won = null;\n\n/**\n * Delimits a race among filters, to be able to disable competing filters when\n * any of them \"wins the race\". `#$#race start; filter1; filter2; race end;`\n * @param {string} action either `start` or `stop` the race.\n * @param {string} winners the amount of possible race's winners: 1 by default.\n */ function race(action, winners = \"1\") {\n    switch (action) {\n      case \"start\":\n        stack = {\n            winners: parseInt(winners, 10) || 1,\n            participants: new Map$2\n        };\n        won = new Array$1;\n        break;\n\n      case \"end\":\n      case \"finish\":\n      case \"stop\":\n        stack = null;\n        for (let win of won) win();\n        won = null;\n        break;\n\n      default:\n        throw new Error$1(`Invalid action: ${action}`);\n    }\n}\n\n/**\n * Returns a function that, when a race is happening, can mark a winner,\n * by invoking all callbacks passed for every other snippet that lost the race.\n * @param {function} lose a callback that, once invoked, will stop the snippet.\n * @returns {function} a callback to invoke whenever a match happens.\n */ function raceWinner(lose) {\n    if (stack === null) return noop;\n    let current = stack;\n    let {participants: participants} = current;\n    participants.set(win, lose);\n    return win;\n    function win() {\n        if (current.winners < 1) return;\n        if (current === stack) {\n            won.push(win);\n        } else {\n            participants.delete(win);\n            if (--current.winners < 1) {\n                for (let looser of participants.values()) looser();\n                participants.clear();\n            }\n        }\n    }\n}\n\n/**\n * Hides any HTML element or one of its ancestors matching a CSS selector if\n * the text content of the element contains a given string.\n * @alias module:content/snippets.hide-if-contains\n *\n * @param {string} search The string to look for in HTML elements. If the\n *   string begins and ends with a slash (`/`), the text in between is treated\n *   as a regular expression.\n * @param {string} selector The CSS selector that an HTML element must match\n *   for it to be hidden.\n * @param {?string} [searchSelector] The CSS selector that an HTML element\n *   containing the given string must match. Defaults to the value of the\n *   `selector` argument.\n *\n * @since Adblock Plus 3.3\n */ function hideIfContains(search, selector = \"*\", searchSelector = null) {\n    let re = toRegExp(search);\n    const mo = hideIfMatches((element => re.test($(element).textContent)), selector, searchSelector);\n    mo.race(raceWinner((() => {\n        mo.disconnect();\n    })));\n}\n\nlet {MutationObserver: MutationObserver$6} = $(window);\n\n/**\n * Hides any HTML element or one of its ancestors matching a CSS selector if\n * the text content of the element contains a given string and, optionally, if\n * the element's computed style contains a given string.\n * @alias module:content/snippets.hide-if-contains-and-matches-style\n *\n * @param {string} search The string to look for in HTML elements. If the\n *   string begins and ends with a slash (`/`), the text in between is treated\n *   as a regular expression.\n * @param {string} selector The CSS selector that an HTML element must match\n *   for it to be hidden.\n * @param {string?} [searchSelector] The CSS selector that an HTML element\n *   containing the given string must match. Defaults to the value of the\n *   `selector` argument.\n * @param {string?} [style] The string that the computed style of an HTML\n *   element matching `selector` must contain. If the string begins and ends\n *   with a slash (`/`), the text in between is treated as a regular\n *   expression.\n * @param {string?} [searchStyle] The string that the computed style of an HTML\n *   element matching `searchSelector` must contain. If the string begins and\n *   ends with a slash (`/`), the text in between is treated as a regular\n *   expression.\n *\n * @since Adblock Plus 3.3.2\n */ function hideIfContainsAndMatchesStyle(search, selector = \"*\", searchSelector = null, style = null, searchStyle = null) {\n    if (searchSelector == null) searchSelector = selector;\n    let searchRegExp = toRegExp(search);\n    let styleRegExp = style ? toRegExp(style) : null;\n    let searchStyleRegExp = searchStyle ? toRegExp(searchStyle) : null;\n    let callback = () => {\n        for (let element of $$(searchSelector)) {\n            if (searchRegExp.test($(element).textContent) && (!searchStyleRegExp || searchStyleRegExp.test(getComputedCSSText(element)))) {\n                let closest = $(element).closest(selector);\n                if (closest && (!styleRegExp || styleRegExp.test(getComputedCSSText(closest)))) {\n                    win();\n                    hideElement(closest);\n                }\n            }\n        }\n    };\n    let mo = new MutationObserver$6(callback);\n    let win = raceWinner((() => mo.disconnect()));\n    mo.observe(document, {\n        childList: true,\n        characterData: true,\n        subtree: true\n    });\n    callback();\n}\n\nlet {clearTimeout: clearTimeout, fetch: fetch, getComputedStyle: getComputedStyle$3, setTimeout: setTimeout, Map: Map$1, MutationObserver: MutationObserver$5, Uint8Array: Uint8Array} = $(window);\n\n/**\n * Hides any HTML element or one of its ancestors matching a CSS selector if\n * the background image of the element matches a given pattern.\n * @alias module:content/snippets.hide-if-contains-image\n *\n * @param {string} search The pattern to look for in the background images of\n *   HTML elements. This must be the hexadecimal representation of the image\n *   data for which to look. If the string begins and ends with a slash (`/`),\n *   the text in between is treated as a regular expression.\n * @param {string} selector The CSS selector that an HTML element must match\n *   for it to be hidden.\n * @param {?string} [searchSelector] The CSS selector that an HTML element\n *   containing the given pattern must match. Defaults to the value of the\n *   `selector` argument.\n *\n * @since Adblock Plus 3.4.2\n */ function hideIfContainsImage(search, selector, searchSelector) {\n    if (searchSelector == null) searchSelector = selector;\n    let searchRegExp = toRegExp(search);\n    let callback = () => {\n        for (let element of $$(searchSelector)) {\n            let style = getComputedStyle$3(element);\n            let match = $(style[\"background-image\"]).match(/^url\\(\"(.*)\"\\)$/);\n            if (match) {\n                fetchContent(match[1]).then((content => {\n                    if (searchRegExp.test(uint8ArrayToHex(new Uint8Array(content)))) {\n                        let closest = $(element).closest(selector);\n                        if (closest) {\n                            win();\n                            hideElement(closest);\n                        }\n                    }\n                }));\n            }\n        }\n    };\n    let mo = new MutationObserver$5(callback);\n    let win = raceWinner((() => mo.disconnect()));\n    mo.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    callback();\n}\n\n/**\n * @typedef {object} FetchContentInfo\n * @property {function} remove\n * @property {Promise} result\n * @property {number} timer\n * @private\n */\n/**\n * @type {Map.<string, FetchContentInfo>}\n * @private\n */ let fetchContentMap = new Map$1;\n\n/**\n * Returns a potentially already resolved fetch auto cleaning, if not requested\n * again, after a certain amount of milliseconds.\n *\n * The resolved fetch is by default `arrayBuffer` but it can be any other kind\n * through the configuration object.\n *\n * @param {string} url The url to fetch\n * @param {object} [options] Optional configuration options.\n *                            By default is {as: \"arrayBuffer\", cleanup: 60000}\n * @param {string} [options.as] The fetch type: \"arrayBuffer\", \"json\", \"text\"..\n * @param {number} [options.cleanup] The cache auto-cleanup delay in ms: 60000\n *\n * @returns {Promise} The fetched result as Uint8Array|string.\n *\n * @example\n * fetchContent('https://any.url.com').then(arrayBuffer => { ... })\n * @example\n * fetchContent('https://a.com', {as: 'json'}).then(json => { ... })\n * @example\n * fetchContent('https://a.com', {as: 'text'}).then(text => { ... })\n * @private\n */ function fetchContent(url, {as: as = \"arrayBuffer\", cleanup: cleanup = 6e4} = {}) {\n    let uid = as + \":\" + url;\n    let details = fetchContentMap.get(uid) || {\n        remove: () => fetchContentMap.delete(uid),\n        result: null,\n        timer: 0\n    };\n    clearTimeout(details.timer);\n    details.timer = setTimeout(details.remove, cleanup);\n    if (!details.result) {\n        details.result = fetch(url).then((res => res[as]())).catch(details.remove);\n        fetchContentMap.set(uid, details);\n    }\n    return details.result;\n}\n\n/**\n * Converts a number to its hexadecimal representation.\n *\n * @param {number} number The number to convert.\n * @param {number} [length] The <em>minimum</em> length of the hexadecimal\n *   representation. For example, given the number `1024` and the length `8`,\n *   the function returns the value `\"00000400\"`.\n *\n * @returns {string} The hexadecimal representation of the given number.\n * @private\n */ function toHex(number, length = 2) {\n    let hex = $(number).toString(16);\n    if (hex.length < length) hex = $(\"0\").repeat(length - hex.length) + hex;\n    return hex;\n}\n\n/**\n * Converts a `Uint8Array` object into its hexadecimal representation.\n *\n * @param {Uint8Array} uint8Array The `Uint8Array` object to convert.\n *\n * @returns {string} The hexadecimal representation of the given `Uint8Array`\n *   object.\n * @private\n */ function uint8ArrayToHex(uint8Array) {\n    return uint8Array.reduce(((hex, byte) => hex + toHex(byte)), \"\");\n}\n\nconst {parseFloat: parseFloat$2, Math: Math$2, MutationObserver: MutationObserver$4, WeakSet: WeakSet$4} = $(window);\n\nconst {min: min} = Math$2;\n\nconst ld = (a, b) => {\n    const len1 = a.length + 1;\n    const len2 = b.length + 1;\n    const d = [ [ 0 ] ];\n    let i = 0;\n    let I = 0;\n    while (++i < len2) d[0][i] = i;\n    i = 0;\n    while (++i < len1) {\n        const c = a[I];\n        let j = 0;\n        let J = 0;\n        d[i] = [ i ];\n        while (++j < len2) {\n            d[i][j] = min(d[I][j] + 1, d[i][J] + 1, d[I][J] + (c != b[J]));\n            ++J;\n        }\n        ++I;\n    }\n    return d[len1 - 1][len2 - 1];\n};\n\n/**\n * Hides any HTML element matching a CSS selector if the text content\n * contains someting similar to the string to search for.\n * @alias module:content/snippets.hide-if-contains-similar-text\n *\n * @param {string} search The string to look for, such as \"Sponsored\" or\n *   similar.\n * @param {string} selector The CSS selector that an HTML element must match\n *   for it to be hidden.\n * @param {?string} [searchSelector] The CSS selector that an HTML element\n *   containing the given string must match. Defaults to the value of the\n *   `selector` argument.\n * @param {?number} [ignoreChars] The amount of extra chars to ignore while\n *   looking for the text, allowing possible intermediate chars. If the\n *   `search` string is \"Sponsored\" and `ignoreChars` is 1, elements containing\n *   \"zSponsored\", as example, will be considered a match too.\n * @param {?number} [maxSearches] The amount of searches to perform. By default\n *   the search is performed through the whole length of the found text. Pass\n *   an integer to never perform more than X searches per node. As example,\n *   if the word to look for is usually at the beginning, use 1 or 2 to\n *   improve performance while surfing.\n *\n * @since @eyeo/snippets 0.5.2\n */ function hideIfContainsSimilarText(search, selector, searchSelector = null, ignoreChars = 0, maxSearches = 0) {\n    const visitedNodes = new WeakSet$4;\n    const debugLog = getDebugger(\"hide-if-contains-similar-text\");\n    const $search = $(search);\n    const {length: length} = $search;\n    const chars = length + parseFloat$2(ignoreChars) || 0;\n    const find = $([ ...$search ]).sort();\n    const guard = parseFloat$2(maxSearches) || Infinity;\n    if (searchSelector == null) searchSelector = selector;\n    debugLog(\"Looking for similar text: \" + $search);\n    const callback = () => {\n        for (const element of $$(searchSelector)) {\n            if (visitedNodes.has(element)) continue;\n            visitedNodes.add(element);\n            const {innerText: innerText} = $(element);\n            const loop = min(guard, innerText.length - chars + 1);\n            for (let i = 0; i < loop; i++) {\n                const str = $(innerText).substr(i, chars);\n                const distance = ld(find, $([ ...str ]).sort()) - ignoreChars;\n                if (distance <= 0) {\n                    const closest = $(element).closest(selector);\n                    debugLog(\"Found similar text: \" + $search, closest);\n                    if (closest) {\n                        win();\n                        hideElement(closest);\n                        break;\n                    }\n                }\n            }\n        }\n    };\n    let mo = new MutationObserver$4(callback);\n    let win = raceWinner((() => mo.disconnect()));\n    mo.observe(document, {\n        childList: true,\n        characterData: true,\n        subtree: true\n    });\n    callback();\n}\n\nlet {getComputedStyle: getComputedStyle$2, Map: Map, WeakSet: WeakSet$3, parseFloat: parseFloat$1} = $(window);\n\nconst {ELEMENT_NODE: ELEMENT_NODE$1, TEXT_NODE: TEXT_NODE} = Node;\n\n/**\n * Hides any HTML element matching a CSS selector if the visible text content\n * of the element contains a given string.\n * @alias module:content/snippets.hide-if-contains-visible-text\n *\n * @param {string} search The string to match to the visible text. Is considered\n *   visible text that isn't hidden by CSS properties or other means.\n *   If the string begins and ends with a slash (`/`), the text in between is\n *   treated as a regular expression.\n * @param {string} selector The CSS selector that an HTML element must match\n *   for it to be hidden.\n * @param {?string} [searchSelector] The CSS selector that an HTML element\n *   containing the given string must match. Defaults to the value of the\n *   `selector` argument.\n * @param {?Array.<string>} [attributes] The CSS attributes a computed style\n *   map of a node should have in order to consider that node hidden.\n *   Syntax: <key>:<value>, where <value> can be a string or a regex (if it\n *   starts and ends with a `/`).\n *\n * @since Adblock Plus 3.11.4\n */ function hideIfContainsVisibleText(search, selector, searchSelector = null, ...attributes) {\n    let entries = $([]);\n    const optionalParameters = new Map([ [ \"-snippet-box-margin\", \"2\" ] ]);\n    for (let attr of attributes) {\n        attr = $(attr);\n        let markerIndex = attr.indexOf(\":\");\n        if (markerIndex < 0) continue;\n        let key = attr.slice(0, markerIndex).trim().toString();\n        let value = attr.slice(markerIndex + 1).trim().toString();\n        if (key && value) {\n            if (optionalParameters.has(key)) optionalParameters.set(key, value); else entries.push([ key, value ]);\n        }\n    }\n    let defaultEntries = $([ [ \"opacity\", \"0\" ], [ \"font-size\", \"0px\" ], [ \"color\", \"rgba(0, 0, 0, 0)\" ] ]);\n    let attributesMap = new Map(defaultEntries.concat(entries));\n    /**\n   * Determines if the text inside the element is visible.\n   *\n   * @param {Element} element The element we are checking.\n   * @param {?CSSStyleDeclaration} style The computed style of element. If\n   *   falsey it will be queried.\n   * @returns {bool} Whether the text is visible.\n   * @private\n   */    function isTextVisible(element, style) {\n        if (!style) style = getComputedStyle$2(element);\n        style = $(style);\n        for (const [key, value] of attributesMap) {\n            let valueAsRegex = toRegExp(value);\n            if (valueAsRegex.test(style.getPropertyValue(key))) return false;\n        }\n        let color = style.getPropertyValue(\"color\");\n        if (style.getPropertyValue(\"background-color\") == color) return false;\n        return true;\n    }\n    /**\n   * Check if a pseudo element has visible text via `content`.\n   *\n   * @param {Element} element The element to check visibility of.\n   * @param {string} pseudo The `::before` or `::after` pseudo selector.\n   * @return {string} The pseudo content or an empty string.\n   * @private\n   */    function getPseudoContent(element, pseudo) {\n        let style = getComputedStyle$2(element, pseudo);\n        if (!isVisible(element, style) || !isTextVisible(element, style)) return \"\";\n        let {content: content} = $(style);\n        if (content && content !== \"none\") {\n            let strings = $([]);\n            content = $(content).trim().replace(/([\"'])(?:(?=(\\\\?))\\2.)*?\\1/g, (value => `\u0001${strings.push($(value).slice(1, -1)) - 1}`));\n            content = content.replace(/\\s*attr\\(\\s*([^\\s,)]+)[^)]*?\\)\\s*/g, ((_, name) => $(element).getAttribute(name) || \"\"));\n            return content.replace(/\\x01(\\d+)/g, ((_, index) => strings[index]));\n        }\n        return \"\";\n    }\n    /**\n   * Checks if child element is 100% included in the parent element.\n   *\n   * @param {Element} childNode\n   * @param {Element} parentNode\n   * @param {Object?} conf\n   * @param {Number?} conf.boxMargin\n   * @returns {boolean}\n   */    function isContained(childNode, parentNode, {boxMargin: boxMargin = 2} = {}) {\n        const child = $(childNode).getBoundingClientRect();\n        const parent = $(parentNode).getBoundingClientRect();\n        const stretchedParent = {\n            left: parent.left - boxMargin,\n            right: parent.right + boxMargin,\n            top: parent.top - boxMargin,\n            bottom: parent.bottom + boxMargin\n        };\n        return stretchedParent.left <= child.left && child.left <= stretchedParent.right && stretchedParent.top <= child.top && child.top <= stretchedParent.bottom && (stretchedParent.top <= child.bottom && child.bottom <= stretchedParent.bottom && stretchedParent.left <= child.right && child.right <= stretchedParent.right);\n    }\n    /**\n   * Returns the visible text content from an element and its descendants.\n   *\n   * @param {Element} element The element whose visible text we want.\n   * @param {Element} closest The closest parent to reach while checking\n   *   for visibility.\n   * @param {?CSSStyleDeclaration} style The computed style of element. If\n   *   falsey it will be queried.\n   * @param {Element} parentOverflowNode The closest parent with overflow hidden\n   * @param {?Object} conf Configuration object\n   * @param {?Number} conf.boxMargin The optional parameter that\n   *   can be used to specify how much to stretch the bounding box of the\n   *   overflow parent in pixels. Used to counter the hiding methods that\n   *   involve pushing decoy elements outside an overflow-y:hidden parent\n   *   to make them invisible. Default is 2 pixels.\n   * @returns {string} The text that is visible.\n   * @private\n   */    function getVisibleContent(element, closest, style, parentOverflowNode, {boxMargin: boxMargin = 2} = {}) {\n        let checkClosest = !style;\n        if (checkClosest) style = getComputedStyle$2(element);\n        if (!isVisible(element, style, checkClosest && closest)) return \"\";\n        if (!parentOverflowNode && ($(style).getPropertyValue(\"overflow-x\") === \"hidden\" || $(style).getPropertyValue(\"overflow-y\") === \"hidden\")) parentOverflowNode = element;\n        let text = getPseudoContent(element, \":before\");\n        for (let node of $(element).childNodes) {\n            switch ($(node).nodeType) {\n              case ELEMENT_NODE$1:\n                text += getVisibleContent(node, element, getComputedStyle$2(node), parentOverflowNode, {\n                    boxMargin: boxMargin\n                });\n                break;\n\n              case TEXT_NODE:\n                if (parentOverflowNode) {\n                    if (isContained(element, parentOverflowNode, {\n                        boxMargin: boxMargin\n                    }) && isTextVisible(element, style)) text += $(node).nodeValue;\n                } else if (isTextVisible(element, style)) {\n                    text += $(node).nodeValue;\n                }\n                break;\n            }\n        }\n        return text + getPseudoContent(element, \":after\");\n    }\n    const boxMarginStr = optionalParameters.get(\"-snippet-box-margin\");\n    const boxMargin = parseFloat$1(boxMarginStr) || 0;\n    let re = toRegExp(search);\n    let seen = new WeakSet$3;\n    const mo = hideIfMatches(((element, closest) => {\n        if (seen.has(element)) return false;\n        seen.add(element);\n        let text = getVisibleContent(element, closest, null, null, {\n            boxMargin: boxMargin\n        });\n        let result = re.test(text);\n        if (debug() && text.length) log(result, re, text);\n        return result;\n    }), selector, searchSelector);\n    mo.race(raceWinner((() => {\n        mo.disconnect();\n    })));\n}\n\nlet {MutationObserver: MutationObserver$3} = $(window);\n\n/**\n * Hides any HTML element or one of its ancestors matching a CSS selector if a\n * descendant of the element matches a given CSS selector and, optionally, if\n * the element's computed style contains a given string.\n * @alias module:content/snippets.hide-if-has-and-matches-style\n *\n * @param {string} search The CSS selector against which to match the\n *   descendants of HTML elements.\n * @param {string} selector The CSS selector that an HTML element must match\n *   for it to be hidden.\n * @param {?string} [searchSelector] The CSS selector that an HTML element\n *   containing the specified descendants must match. Defaults to the value of\n *   the `selector` argument.\n * @param {?string} [style] The string that the computed style of an HTML\n *   element matching `selector` must contain. If the string begins and ends\n *   with a slash (`/`), the text in between is treated as a regular\n *   expression.\n * @param {?string} [searchStyle] The string that the computed style of an HTML\n *   element matching `searchSelector` must contain. If the string begins and\n *   ends with a slash (`/`), the text in between is treated as a regular\n *   expression.\n *\n * @since Adblock Plus 3.4.2\n */ function hideIfHasAndMatchesStyle(search, selector = \"*\", searchSelector = null, style = null, searchStyle = null) {\n    if (searchSelector == null) searchSelector = selector;\n    let styleRegExp = style ? toRegExp(style) : null;\n    let searchStyleRegExp = searchStyle ? toRegExp(searchStyle) : null;\n    let callback = () => {\n        for (let element of $$(searchSelector)) {\n            if ($(element).querySelector(search) && (!searchStyleRegExp || searchStyleRegExp.test(getComputedCSSText(element)))) {\n                let closest = $(element).closest(selector);\n                if (closest && (!styleRegExp || styleRegExp.test(getComputedCSSText(closest)))) {\n                    win();\n                    hideElement(closest);\n                }\n            }\n        }\n    };\n    let mo = new MutationObserver$3(callback);\n    let win = raceWinner((() => mo.disconnect()));\n    mo.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    callback();\n}\n\nlet {getComputedStyle: getComputedStyle$1, MutationObserver: MutationObserver$2, WeakSet: WeakSet$2} = $(window);\n\n/**\n * Hides any HTML element that uses an `aria-labelledby`, or one of its\n * ancestors, if the related aria element contains the searched text.\n * @alias module:content/snippets.hide-if-labelled-by\n *\n * @param {string} search The string to look for in HTML elements. If the\n *   string begins and ends with a slash (`/`), the text in between is treated\n *   as a regular expression.\n * @param {string} selector The CSS selector of an HTML element that uses as\n *   `aria-labelledby` attribute.\n * @param {?string} [searchSelector] The CSS selector of an ancestor of the\n *   HTML element that uses as `aria-labelledby` attribute. Defaults to the\n *   value of the `selector` argument.\n *\n * @since Adblock Plus 3.9\n */ function hideIfLabelledBy(search, selector, searchSelector = null) {\n    let sameSelector = searchSelector == null;\n    let searchRegExp = toRegExp(search);\n    let matched = new WeakSet$2;\n    let callback = () => {\n        for (let node of $$(selector)) {\n            let closest = sameSelector ? node : $(node).closest(searchSelector);\n            if (!closest || !isVisible(node, getComputedStyle$1(node), closest)) continue;\n            let attr = $(node).getAttribute(\"aria-labelledby\");\n            let fallback = () => {\n                if (matched.has(closest)) return;\n                if (searchRegExp.test($(node).getAttribute(\"aria-label\") || \"\")) {\n                    win();\n                    matched.add(closest);\n                    hideElement(closest);\n                }\n            };\n            if (attr) {\n                for (let label of $(attr).split(/\\s+/)) {\n                    let target = $(document).getElementById(label);\n                    if (target) {\n                        if (!matched.has(target) && searchRegExp.test(target.innerText)) {\n                            win();\n                            matched.add(target);\n                            hideElement(closest);\n                        }\n                    } else {\n                        fallback();\n                    }\n                }\n            } else {\n                fallback();\n            }\n        }\n    };\n    let mo = new MutationObserver$2(callback);\n    let win = raceWinner((() => mo.disconnect()));\n    mo.observe(document, {\n        characterData: true,\n        childList: true,\n        subtree: true\n    });\n    callback();\n}\n\nlet {Math: Math$1, setInterval: setInterval, chrome: chrome$2, isExtensionContext: isExtensionContext$1, performance: performance$1} = $(window);\n\n/**\n * Default profile(\"...\") returned object when profile mode is disabled.\n * @type {Profiler}\n * @private\n */ const noopProfile = {\n    mark() {},\n    end() {},\n    toString() {\n        return \"{mark(){},end(){}}\";\n    }\n};\n\n/**\n * Whether profile mode is inactive.\n * @type {boolean}\n * @private\n */ let inactive = true;\n\n/**\n * Enables profile mode.\n * @alias module:content/snippets.profile\n * @since Adblock Plus 3.9\n *\n * @example\n * example.com#$#profile; log 'Hello, world!'\n */ function setProfile() {\n    inactive = false;\n}\n\n/**\n * @typedef {object} Profiler\n * @property {function} mark Add a `performance.mark(uniqueId)` entry.\n * @property {function} end Measure and clear `uniqueId` related marks. If a\n * `true` value is passed as argument, clear related interval and process all\n * collected samples since the creation of the profiler.\n * @private\n */\n/**\n * Create an object with `mark()` and `end()` methods to either keep marking a\n * specific profiled name, or ending it.\n *\n * @example\n * let {mark, end} = profile('console.log');\n * mark();\n * console.log(1, 2, 3);\n * end();\n *\n * @param {string} id the callback name or unique ID to profile.\n * @param {number} [rate] The number of times per minute to process samples.\n * @returns {Profiler} The profiler with `mark()` and `end(clear = false)`\n * methods.\n * @private\n */ function profile(id, rate = 10) {\n    if (inactive || !isExtensionContext$1) return noopProfile;\n    function processSamples() {\n        let samples = $([]);\n        for (let {name: name, duration: duration} of performance$1.getEntriesByType(\"measure\")) samples.push({\n            name: name,\n            duration: duration\n        });\n        if (samples.length) {\n            performance$1.clearMeasures();\n            chrome$2.runtime.sendMessage({\n                type: \"ewe:profiler.sample\",\n                category: \"snippets\",\n                samples: samples\n            });\n        }\n    }\n    if (!profile[id]) {\n        profile[id] = setInterval(processSamples, Math$1.round(6e4 / Math$1.min(60, rate)));\n    }\n    return {\n        mark() {\n            performance$1.mark(id);\n        },\n        end(clear = false) {\n            performance$1.measure(id, id);\n            performance$1.clearMarks(id);\n            if (clear) {\n                clearInterval(profile[id]);\n                delete profile[id];\n                processSamples();\n            }\n        }\n    };\n}\n\nlet {MutationObserver: MutationObserver$1} = $(window);\n\nconst {ELEMENT_NODE: ELEMENT_NODE} = Node;\n\n/**\n * Hide a specific element through a XPath 1.0 query string.\n * See {@tutorial xpath-filters} to know more.\n * @alias module:content/snippets.hide-if-matches-xpath\n *\n * @param {string} query The XPath query that targets the element to hide.\n *\n * @since Adblock Plus 3.9.0\n */ function hideIfMatchesXPath(query) {\n    let {mark: mark, end: end} = profile(\"hide-if-matches-xpath\");\n    let queryAndApply = initQueryAndApply(`xpath(${query})`);\n    let callback = () => {\n        mark();\n        queryAndApply((node => {\n            win();\n            if ($(node).nodeType === ELEMENT_NODE) hideElement(node); else $(node).textContent = \"\";\n        }));\n        end();\n    };\n    let mo = new MutationObserver$1(callback);\n    let win = raceWinner((() => mo.disconnect()));\n    mo.observe(document, {\n        characterData: true,\n        childList: true,\n        subtree: true\n    });\n    callback();\n}\n\nlet {chrome: chrome$1, getComputedStyle: getComputedStyle, isExtensionContext: isExtensionContext, parseFloat: parseFloat, Array: Array, MutationObserver: MutationObserver, Object: Object$1, WeakSet: WeakSet$1} = $(window);\n\nlet {filter: filter, map: map, push: push, reduce: reduce, some: some} = caller(window.Array.prototype);\n\n/**\n * Hides any HTML element if its structure (graph) is classified as an ad\n * by a built-in machine learning model.\n * @alias module:content/snippets.hide-if-graph-matches\n *\n * @param {string} selector A selector that produces a list of targets to\n * classify.\n * @param {string} tagName An HTML tag name to filter mutations.\n *\n * @since Adblock Plus 3.11.3\n */ function hideIfGraphMatches(selector, tagName) {\n    let scheduled = false;\n    let seenMlTargets = new WeakSet$1;\n    let relevantTagName = tagName;\n    let callback = mutations => {\n        for (let mutation of $(mutations)) {\n            let {target: target} = $(mutation, \"MutationRecord\");\n            if ($(target).tagName == relevantTagName) {\n                if (!scheduled) {\n                    scheduled = true;\n                    requestAnimationFrame((() => {\n                        scheduled = false;\n                        predictAds(win, selector, seenMlTargets);\n                    }));\n                }\n                break;\n            }\n        }\n    };\n    let mo = new MutationObserver(callback);\n    let win = raceWinner((() => mo.disconnect()));\n    mo.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    predictAds(win, selector, seenMlTargets);\n}\n\nconst GRAPH_CUT_OFF = 50;\n\nconst THRESHOLD = .5;\n\nconst CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = \"The message port closed before a response was received.\";\n\nconst sendMessage = message => new Promise(((resolve, reject) => {\n    chrome$1.runtime.sendMessage(message, (response => {\n        if (chrome$1.runtime.lastError) {\n            if (chrome$1.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) resolve(); else reject(new Error(chrome$1.runtime.lastError.message));\n        } else {\n            resolve(response);\n        }\n    }));\n}))\n/**\n * Builds an adjecency matrix and a feature matrix based on an input element.\n * @param {Element} target Input element to convert.\n * @returns {Tuple} (adjMatrix, elementTags) - a 2D array that represent an\n * adjacency matrix of an element. HTML elements are undirected trees, so the\n * adjacency matrix is symmetric.\n * elementTags - a 1D feature matrix, where each element is represents a type\n * of a node.\n * @private\n */;\n\nfunction processElement(target) {\n    let {adjacencyMatrix: adjacencyMatrix, features: features} = addEdgesFeatures(target, GRAPH_CUT_OFF);\n    return {\n        adjacencyMatrix: adjacencyMatrix,\n        features: features\n    };\n}\n\n/**\n * Runs a ML prediction on each element that matches a selector.\n * @param {function} win A callback used to flag a matched case/element.\n * @param {string} selector A selector to use for finding candidates.\n * @param {WeakSet} seenMlTargets Matched elements to ignore.\n *\n * @private\n */ function predictAds(win, selector, seenMlTargets) {\n    let debugLog = getDebugger(\"hide-if-graph-matches\");\n    let targets = $$(selector);\n    for (let target of targets) {\n        if (seenMlTargets.has(target)) continue;\n        if ($(target).innerText == \"\") continue;\n        seenMlTargets.add(target);\n        let processedElement = processElement(target);\n        let {mark: mark, end: end} = profile(`ml:inference:${randomId()}`);\n        mark();\n        let message = {\n            type: \"ewe:ml-inference\",\n            inputs: [ {\n                data: [ processedElement.adjacencyMatrix ],\n                preprocess: [ {\n                    funcName: \"padAdjacency\",\n                    args: GRAPH_CUT_OFF\n                }, {\n                    funcName: \"unstack\"\n                }, {\n                    funcName: \"localPooling\"\n                }, {\n                    funcName: \"stack\"\n                } ]\n            }, {\n                data: [ processedElement.features ],\n                preprocess: [ {\n                    funcName: \"padFeatures\",\n                    args: GRAPH_CUT_OFF\n                }, {\n                    funcName: \"cast\",\n                    args: \"float32\"\n                } ]\n            } ],\n            model: \"hideIfGraphMatches\"\n        };\n        let process = function(rawPrediction) {\n            if (!rawPrediction) return;\n            let predictionValues = Object$1.values(rawPrediction);\n            if (!some(predictionValues, (value => value > 0))) debugLog(\"Error: ML prediction results are corrupted\");\n            let norm = reduce(predictionValues, ((acc, val) => acc + val), 0);\n            let normPredictionValues = map(predictionValues, (val => val / norm));\n            let result = map(filter(normPredictionValues, ((_, index) => index % 2 == 1)), (element => element > THRESHOLD));\n            if (result[0]) {\n                debugLog(\"Detected ad: \" + $(target).innerText);\n                win();\n                hideElement(target);\n            }\n        };\n        if (isExtensionContext) {\n            sendMessage(message).then((response => {\n                if (response) {\n                    process(response);\n                    debugLog(response);\n                } else {\n                    message.type = \"ml.inference\";\n                    sendMessage(message).then(process).catch(debugLog);\n                }\n                end(true);\n            })).catch(debugLog);\n        }\n    }\n}\n\nclass GraphNode {\n    /**\n   * Initializes a Node with the tag name and attributed related to the node.\n   * @param {string} tag - name of the tag which represents the node\n   * @param {Object} attributes - attributes related to the node\n   * @private\n   */\n    constructor(tag, attributes) {\n        this.tag = tag;\n        this.attributes = attributes;\n        this.children = [];\n        this.elementHidden = false;\n        this.elementBlocked = false;\n        this.filter = null;\n        this.requestType = null;\n        this.height = 0;\n        this.width = 0;\n        this.cssSelectors = null;\n    }\n    /**\n   * Adds a child node to the current GraphNode.\n   * @param {GraphNode} newChild - the child node to be added.\n   */    addChild(newChild) {\n        push(this.children, newChild);\n    }\n}\n\nconst IMPORTANT_NODE_ATTRIBUTES = [ \"style\" ];\n\n/**\n * Returns a new Object of attributes with only the important ones.\n * @param {Object} object - attributes to be filtered\n *\n * @return {Object} - the filtered attributes\n */ function cloneObject(object) {\n    let newObject = {};\n    for (let attr in object) {\n        if (object[attr]) newObject[attr] = object[attr];\n    }\n    return newObject;\n}\n\n/**\n * Given a DOM tree, returns the adjacency matrix and features array after\n * doing DFS through the graph.\n *\n * @param {Object} target - the node to start the DFS from\n * @param {number} cutoff - the maximum number of nodes to be added.\n *\n * @returns {Object} - the adjacency matrix and features array\n */ function addEdgesFeatures(target, cutoff) {\n    let emptyMatrix = new Array(cutoff);\n    for (let i = 0; i < cutoff; i++) emptyMatrix[i] = new Array(cutoff).fill(0);\n    let adjacencyMatrix = emptyMatrix;\n    let features = [];\n    let numOfElements = 0;\n    /**\n   * DFS through the DOM tree and creates GraphNode, which is used for\n   * generating features and adjacency matrix.\n   *\n   * @param {Object} element - the node to process in one step of DFS\n   * @param {GraphNode} parentNode - the parent node of the current nodeId\n   */    function domToGraph(element, parentNode) {\n        if (numOfElements >= cutoff) return;\n        let attributes = {};\n        for (let attr of $(element).attributes) attributes[$(attr).name] = $(attr).value;\n        for (let attr of IMPORTANT_NODE_ATTRIBUTES) attributes[attr] = cloneObject(element[attr]);\n        let node = new GraphNode(element.tagName, attributes);\n        node.cssSelectors = getComputedStyle(element).cssText;\n        node.height = element.clientHeight;\n        node.width = element.clientWidth;\n        node.nodeId = numOfElements;\n        numOfElements += 1;\n        if (parentNode !== null) {\n            adjacencyMatrix[parentNode.nodeId][node.nodeId] = 1;\n            adjacencyMatrix[node.nodeId][parentNode.nodeId] = 1;\n        }\n        if (parentNode == null) {\n            node.nodeLevel = 0;\n            node.parentNodeId = 0;\n            node.siblings = 0;\n        } else {\n            node.nodeLevel = parentNode.nodeLevel + 1;\n            node.parentNodeId = parentNode.nodeId;\n            node.siblings = parentNode.children.length;\n        }\n        node.numChildren = element.children.length;\n        if (node.attributes.hasOwnProperty(\"src\") && node.attributes[\"src\"] !== undefined) {\n            node.attributes[\"src_level\"] = 0;\n        } else if (parentNode !== null && Object$1.values(parentNode.attributes).length !== 0 && parentNode.attributes.hasOwnProperty(\"src\") && parentNode.attributes[\"src\"] !== undefined) {\n            node.attributes[\"src\"] = parentNode.attributes[\"src\"];\n            node.attributes[\"src_level\"] = parentNode.attributes[\"src_level\"] + 1;\n            node[\"requestType\"] = parentNode[\"requestType\"];\n        }\n        node.features = (new featureGenerator).getNodeFeatures(node, location.href, true, true, true, true);\n        push(features, node.features);\n        for (let child of element.children) domToGraph(child, node);\n    }\n    domToGraph(target, null);\n    return {\n        adjacencyMatrix: adjacencyMatrix,\n        features: features\n    };\n}\n\n/**\n * Function to generate an eye matrix\n * @param {number} n - size of the matrix\n * @returns {Array} - the eye matrix\n */ let eye = function(n) {\n    let matrix = [];\n    for (let i = 0; i < n; i++) {\n        let content = [];\n        for (let k = 0; k < n; k++) push(content, i === k ? 1 : 0);\n        push(matrix, content);\n    }\n    return matrix;\n};\n\nconst DISPLAY_ATTR_MAP = {\n    none: 1,\n    inline: 2,\n    block: 3,\n    \"inline-block\": 4,\n    inherit: 5\n};\n\nconst ONE_HOT_DISPLAY_LEN = 5;\n\nconst NUM_CSS_SELECTORS = 55;\n\nconst CSS_COLORS = [ \"background-color\", \"border-bottom-color\", \"border-left-color\", \"border-right-color\", \"border-top-color\", \"color\", \"outline-color\", \"text-decoration\", \"text-decoration-color\", \"column-rule-color\", \"-webkit-text-emphasis-color\", \"-webkit-text-fill-color\", \"-webkit-text-stroke-color\", \"caret-color\" ];\n\nconst CSS_PIXELS = [ \"border-bottom-width\", \"height\", \"min-height\", \"min-width\", \"padding-bottom\", \"padding-left\", \"padding-right\", \"padding-top\", \"width\" ];\n\nconst CSS_ORIGINS = [ \"perspective-origin\", \"transform-origin\" ];\n\nconst REQUEST_TYPES = [ \"script\", \"subdocument\", \"image\", \"xmlhttprequest\", \"font\", \"document\", \"stylesheet\", \"other\", \"ping\", \"websocket\", \"media\", \"object\" ];\n\nlet requestTypesDict = {};\n\nconst reqtypeVEC = eye(REQUEST_TYPES.length);\n\nfor (let ob in REQUEST_TYPES) requestTypesDict[REQUEST_TYPES[ob]] = reqtypeVEC[ob];\n\nconst URL_CHARS = \" abcdefghijklmnopqrstuvwxyz1234567890:;/?!=+.,()[]-`*_|~\".split(\"\");\n\nlet wordIndex = {};\n\nlet charEncoderIndex = 1;\n\nURL_CHARS.forEach((char => {\n    wordIndex[char] = charEncoderIndex;\n    charEncoderIndex += 1;\n}));\n\nlet featureGenerator = function() {\n    let appendFeatures = function(features, arr) {\n        map(arr, (el => push(features, el)));\n    };\n    /**\n   * Generates a sequence for a given string based on a wordIndex\n   *\n   * @param {string} st - the string to generate the sequence for\n   * @param {number} maxLen - the maximum length of the sequences\n   * @returns {Array} - the generated sequence\n   */    let getStringSeq = function(st, maxLen) {\n        let seq = [];\n        st = st.split(\"\");\n        st.forEach((char => {\n            push(seq, wordIndex.hasOwnProperty(char) ? wordIndex[char] : -1);\n        }));\n        if (seq.length > maxLen) return seq.slice(-maxLen);\n        appendFeatures(seq, new Array(maxLen - seq.length).fill(0));\n        return seq;\n    };\n    /**\n   * Gets the vector for a given tag name.\n   *\n   * @param {Object} node - The node that contains the tag\n   * @param {number} maxLen - The maximum length of the sequence\n   * @returns {Array} - The vector for the tag\n   */    let getTagVec = function(node, maxLen = 8) {\n        let tag = node[\"tag\"].toLowerCase();\n        let tagVec = getStringSeq(tag, maxLen);\n        return tagVec;\n    };\n    /**\n   * Returns the meta features for the domains\n   *\n   * @param {Object} node - The node that contains the domain\n   * @param {string} domain - The domain\n   * @param {string} target - target field\n   * @returns {Array} - The meta features for the domain\n   */    let getMetaFeatures = function(node, domain, target) {\n        let sourceIsUrl = 0;\n        let hasSource = 0;\n        let sourceIsThirdParty = 0;\n        let attrs = node[\"attributes\"];\n        if (attrs !== undefined && attrs.hasOwnProperty(target)) {\n            let src = attrs[target].toLowerCase();\n            hasSource = 1;\n            if (src.startsWith(\"http\") == true) sourceIsUrl = 1;\n            let pathArray = src.split(\"/\");\n            let netloc = pathArray[2];\n            if (netloc !== domain) sourceIsThirdParty = 1;\n        }\n        return [ hasSource, sourceIsUrl, sourceIsThirdParty ];\n    };\n    /**\n   * Gets rgb features for a given rgb_string\n   *\n   * @param {String} rgbString - The rgb string\n   * @returns {Array} - The rgb features\n   */    let getRgb = function(rgbString) {\n        let regex = /rgba?\\((\\d+), (\\d+), (\\d+)\\)/g;\n        let rgbColors = regex.exec(rgbString);\n        if (rgbColors) {\n            return [ parseFloat(rgbColors[1]), parseFloat(rgbColors[2]), parseFloat(rgbColors[3]) ];\n        }\n        return [ 0, 0, 0 ];\n    };\n    /**\n   * Gets pixels from a pixel strings\n   *\n   * @param {String} pxString - The pixel string\n   * @returns {Array} - The pixels\n   */    let getPixels = function(pxString) {\n        let regex = /(\\d*?\\.?\\d*)px/g;\n        let pixel = regex.exec(pxString);\n        if (pixel) return [ parseFloat(pixel[1]) ];\n        return [ 0 ];\n    };\n    /**\n   * Gets origins for a css coordinate string\n   *\n   * @param {String} originString - The css string\n   * @returns {Array} - The origins\n   */    let getOrigins = function(originString) {\n        let regex = /(\\d*?\\.?\\d*)px (\\d*?\\.?\\d*)px/g;\n        let origin = regex.exec(originString);\n        if (origin) return [ parseFloat(origin[1]), parseFloat(origin[2]) ];\n        return [ 0, 0 ];\n    };\n    /**\n   * Returns the css features for a given node\n   *\n   * @param {Object} node - The node that contains the css\n   * @returns {Array} - The css features\n   */    let getCssFeatures = function(node) {\n        let css = node[\"cssSelectors\"];\n        if (!css) return new Array(NUM_CSS_SELECTORS).fill(0);\n        let cssAttrs = {};\n        let spl = css.split(\"; \");\n        for (let element in spl) {\n            let el = spl[element].split(\":\");\n            let x = el[0];\n            let y = el[1];\n            if (x !== undefined && y !== undefined) cssAttrs[x.trim()] = y.trim();\n        }\n        let cssFeatures = [];\n        for (let color in CSS_COLORS) {\n            let cssColors = cssAttrs.hasOwnProperty(CSS_COLORS[color]) ? getRgb(cssAttrs[CSS_COLORS[color]]) : [ 0, 0, 0 ];\n            appendFeatures(cssFeatures, cssColors);\n        }\n        for (let px in CSS_PIXELS) {\n            let cssPixels = cssAttrs.hasOwnProperty(CSS_PIXELS[px]) ? getPixels(cssAttrs[CSS_PIXELS[px]]) : [ 0 ];\n            appendFeatures(cssFeatures, cssPixels);\n        }\n        for (let origin in CSS_ORIGINS) {\n            let cssOrigins = cssAttrs.hasOwnProperty(CSS_ORIGINS[origin]) ? getOrigins(cssAttrs[CSS_ORIGINS[origin]]) : [ 0, 0 ];\n            appendFeatures(cssFeatures, cssOrigins);\n        }\n        return cssFeatures;\n    };\n    /**\n   * Returns all style features including css features\n   *\n   * @param {Object} node - The node that contains the features to be extracted\n   * @returns {Array} - The style features\n   */    let getStyleFeatures = function(node) {\n        let attrs = node.hasOwnProperty(\"attributes\") ? node[\"attributes\"] : {};\n        let styleAttrs = attrs.hasOwnProperty(\"style\") ? attrs[\"style\"] : {};\n        let offsetHeight = styleAttrs.hasOwnProperty(\"offsetHeight\") ? styleAttrs[\"offsetHeight\"] : \"0\";\n        if (offsetHeight) offsetHeight = parseFloat(offsetHeight.trim());\n        let offsetWidth = styleAttrs.hasOwnProperty(\"offsetWidth\") ? styleAttrs[\"offsetWidth\"] : \"0\";\n        if (offsetWidth) offsetWidth = parseFloat(offsetWidth.trim());\n        let displayAttr = styleAttrs.hasOwnProperty(\"display\") ? styleAttrs[\"display\"] : \"-1\";\n        if (displayAttr) displayAttr.trim().toLowerCase();\n        displayAttr = DISPLAY_ATTR_MAP.hasOwnProperty(displayAttr) ? DISPLAY_ATTR_MAP[displayAttr] : 0;\n        let displayVec = new Array(ONE_HOT_DISPLAY_LEN).fill(0);\n        if (displayAttr > 0) displayVec[displayAttr - 1] = 1;\n        let styleFeatures = [ offsetHeight, offsetWidth ];\n        appendFeatures(styleFeatures, displayVec);\n        let fontSize = styleAttrs.hasOwnProperty(\"font-size\") ? styleAttrs[\"font-size\"] : 0;\n        if (fontSize) fontSize = parseFloat(fontSize.trim().toLowerCase().replace(\"px\", \"\"));\n        push(styleFeatures, fontSize);\n        return styleFeatures;\n    };\n    /**\n   * Given a node, generates all features related to it.\n   *\n   * @param {Object} node - The node that contains the features to be extracted\n   * @param {string} domain - The domain of the node\n   * @param {boolean} topLevel - Whether to include top_level features\n   * @param {boolean} attributes - Whether to include attributes features\n   * @param {boolean} style - Whether to include style features\n   * @param {boolean} css - Whether to include css features\n   *\n   * @returns {Array} - The features\n   */    this.getNodeFeatures = function(node, domain, topLevel = true, attributes = false, style = false, css = false) {\n        let features = [];\n        if (topLevel == true) {\n            push(features, node.nodeId);\n            push(features, node.parentNodeId);\n            push(features, node.siblings);\n            appendFeatures(features, getTagVec(node));\n            push(features, node.nodeLevel);\n            push(features, node.numChildren);\n            let reqType = node.hasOwnProperty(\"requestType\") ? node[\"requestType\"] : null;\n            if (reqType !== null) reqType = reqType.toLowerCase();\n            let reqTypeVec = new Array(REQUEST_TYPES.length).fill(0);\n            if (reqType !== null && requestTypesDict.hasOwnProperty(reqType)) reqTypeVec = requestTypesDict[reqType];\n            appendFeatures(features, reqTypeVec);\n        }\n        if (attributes == true) {\n            let attrs = node.hasOwnProperty(\"attributes\") ? node[\"attributes\"] : undefined;\n            let src = \"\";\n            if (attrs != undefined && attrs.hasOwnProperty(\"src\")) {\n                src = attrs[\"src\"];\n                src = src.trim().toLowerCase();\n            }\n            appendFeatures(features, getStringSeq(src, 256));\n            appendFeatures(features, getMetaFeatures(node, domain, \"src\"));\n            let href = \"\";\n            if (attrs != undefined && attrs.hasOwnProperty(\"href\")) {\n                href = attrs[\"href\"];\n                href = href.trim().toLowerCase();\n            }\n            appendFeatures(features, getStringSeq(href, 256));\n            appendFeatures(features, getMetaFeatures(node, domain, \"href\"));\n            let id = \"\";\n            if (attrs != undefined && attrs.hasOwnProperty(\"id\")) {\n                id = attrs[\"id\"];\n                id = id.trim().toLowerCase();\n                id = id.replace(/[!\"'\\(\\)\\*,\\-\\.\\/:;\\?\\[\\\\\\]\\^_`\\{\\|\\}~ ]/g, \" \").replace(/\\s+/g, \" \");\n            }\n            appendFeatures(features, getStringSeq(id, 16));\n            let clas = \"\";\n            if (attrs != undefined && attrs.hasOwnProperty(\"class\")) {\n                clas = attrs[\"class\"];\n                clas = clas.trim().toLowerCase();\n                clas = clas.replace(/[!\"'\\(\\)\\*,\\-\\.\\/:;\\?\\[\\\\\\]\\^_`\\{\\|\\}~ ]/g, \" \").replace(/\\s+/g, \" \");\n            }\n            appendFeatures(features, getStringSeq(clas, 16));\n        }\n        if (style == true) appendFeatures(features, getStyleFeatures(node));\n        if (css == true) appendFeatures(features, getCssFeatures(node));\n        return features;\n    };\n};\n\nconst snippets = {\n    log: log,\n    race: race,\n    debug: setDebug,\n    profile: setProfile,\n    \"hide-if-matches-xpath\": hideIfMatchesXPath,\n    \"hide-if-contains\": hideIfContains,\n    \"hide-if-contains-similar-text\": hideIfContainsSimilarText,\n    \"hide-if-contains-visible-text\": hideIfContainsVisibleText,\n    \"hide-if-contains-and-matches-style\": hideIfContainsAndMatchesStyle,\n    \"hide-if-has-and-matches-style\": hideIfHasAndMatchesStyle,\n    \"hide-if-labelled-by\": hideIfLabelledBy,\n    \"hide-if-contains-image\": hideIfContainsImage,\n    \"hide-if-graph-matches\": hideIfGraphMatches,\n    \"simulate-event-poc\": simulateEvent\n};\n\nconst dependencies = {};\n\nexports.dependencies = dependencies;\n\nexports.snippets = snippets;\n","injectedList":["abort-current-inline-script","abort-on-iframe-property-read","abort-on-iframe-property-write","abort-on-property-read","abort-on-property-write","cookie-remover","debug","freeze-element","hide-if-shadow-contains","json-override","json-prune","override-property-read","prevent-listener","strip-fetch-query-parameter","trace"]}